<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2&nbsp; Lineare Regression – Machine Learning verstehen statt nur anwenden</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./03_linclass.html" rel="next">
<link href="./classical.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-60bb1717b56a62d0d19126c2c8ec626d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zusätzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zurücksetzen",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./classical.html">Klassisches Machine Learning</a></li><li class="breadcrumb-item"><a href="./02_linreg.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Lineare Regression</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Suchen" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Machine Learning verstehen statt nur anwenden</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Über das Buch</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Einführung</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./classical.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Klassisches Machine Learning</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_linreg.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Lineare Regression</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_linclass.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Lineare Klassifikation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_pipeline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">ML Pipeline</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_tree.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Entscheidungsbäume</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_ensemble.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Ensembles</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07_svm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Support Vector Machines</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./deep.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Deep Learning</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08_ann.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Artificial Neural Networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09_cnn.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Convolutional Neural Networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10_rnn.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Recurrent Neural Networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11_transformer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Transformers</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Quellenverzeichnis</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Anhang</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./math.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Mathe- und Statistik-Grundlagen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">R und Python</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Inhaltsverzeichnis</h2>
   
  <ul>
  <li><a href="#ml-modelle-im-allgemeinen" id="toc-ml-modelle-im-allgemeinen" class="nav-link active" data-scroll-target="#ml-modelle-im-allgemeinen"><span class="header-section-number">2.1</span> ML-Modelle im Allgemeinen</a></li>
  <li><a href="#das-modell-ausgeschrieben" id="toc-das-modell-ausgeschrieben" class="nav-link" data-scroll-target="#das-modell-ausgeschrieben"><span class="header-section-number">2.2</span> Das Modell (ausgeschrieben)</a></li>
  <li><a href="#das-modell-kompakt" id="toc-das-modell-kompakt" class="nav-link" data-scroll-target="#das-modell-kompakt"><span class="header-section-number">2.3</span> Das Modell (kompakt)</a></li>
  <li><a href="#modelltraining" id="toc-modelltraining" class="nav-link" data-scroll-target="#modelltraining"><span class="header-section-number">2.4</span> Modelltraining</a>
  <ul class="collapse">
  <li><a href="#perspektive-1-funktionsoptimierung" id="toc-perspektive-1-funktionsoptimierung" class="nav-link" data-scroll-target="#perspektive-1-funktionsoptimierung"><span class="header-section-number">2.4.1</span> Perspektive 1: Funktionsoptimierung</a></li>
  <li><a href="#perspektive-2-wahrscheinlichkeitstheorie" id="toc-perspektive-2-wahrscheinlichkeitstheorie" class="nav-link" data-scroll-target="#perspektive-2-wahrscheinlichkeitstheorie"><span class="header-section-number">2.4.2</span> Perspektive 2: Wahrscheinlichkeitstheorie</a></li>
  </ul></li>
  <li><a href="#regularisierte-regression" id="toc-regularisierte-regression" class="nav-link" data-scroll-target="#regularisierte-regression"><span class="header-section-number">2.5</span> Regularisierte Regression</a>
  <ul class="collapse">
  <li><a href="#ridge-regressionsmodell" id="toc-ridge-regressionsmodell" class="nav-link" data-scroll-target="#ridge-regressionsmodell"><span class="header-section-number">2.5.1</span> Ridge Regressionsmodell</a></li>
  <li><a href="#lasso-regressionsmodell" id="toc-lasso-regressionsmodell" class="nav-link" data-scroll-target="#lasso-regressionsmodell"><span class="header-section-number">2.5.2</span> LASSO Regressionsmodell</a></li>
  </ul></li>
  <li><a href="#bias-variance-tradeoff" id="toc-bias-variance-tradeoff" class="nav-link" data-scroll-target="#bias-variance-tradeoff"><span class="header-section-number">2.6</span> Bias-Variance Tradeoff</a></li>
  <li><a href="#polynomische-regression" id="toc-polynomische-regression" class="nav-link" data-scroll-target="#polynomische-regression"><span class="header-section-number">2.7</span> Polynomische Regression</a></li>
  <li><a href="#lineare-regression-in-r" id="toc-lineare-regression-in-r" class="nav-link" data-scroll-target="#lineare-regression-in-r"><span class="header-section-number">2.8</span> Lineare Regression in R</a>
  <ul class="collapse">
  <li><a href="#base-r" id="toc-base-r" class="nav-link" data-scroll-target="#base-r"><span class="header-section-number">2.8.1</span> Base <code>R</code></a></li>
  <li><a href="#tidymodels-glmnet" id="toc-tidymodels-glmnet" class="nav-link" data-scroll-target="#tidymodels-glmnet"><span class="header-section-number">2.8.2</span> <code>tidymodels</code> + <code>glmnet</code></a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./classical.html">Klassisches Machine Learning</a></li><li class="breadcrumb-item"><a href="./02_linreg.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Lineare Regression</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-linreg" class="quarto-section-identifier"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Lineare Regression</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>In diesem Kapitel werden wir uns eingehend mit dem einfachsten Modell für das Regressionsproblem auseinander setzen, nämlich dem linearen Regressionsmodell. Liegt ein Regressionsproblem vor, dann macht es in der Praxis fast immer Sinn mit diesem Modell zu starten und dann die Komplexität nach Bedarf zu erhöhen.</p>
<section id="ml-modelle-im-allgemeinen" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="ml-modelle-im-allgemeinen"><span class="header-section-number">2.1</span> ML-Modelle im Allgemeinen</h2>
<p>Wie bereits in <a href="01_intro.html" class="quarto-xref"><span>Kapitel 1</span></a> gesehen, geht es beim Regressionsproblem darum, eine stetige Variable <span class="math inline">\(y_i \in \mathbb{R}\)</span> möglichst optimal vorherzusagen. Dazu verwenden wir eine oder mehrere Input-Variablen, welche wir kompakt als Vektor <span class="math inline">\(\mathbf{x}_i\)</span> schreiben.</p>
<p>Das Problem ist nur sinnvoll lösbar, falls es tatsächlich einen Zusammenhang zwischen den Input-Variablen <span class="math inline">\(\mathbf{x}_i\)</span> und dem Output <span class="math inline">\(y_i\)</span> gibt, wenn wir also aus <span class="math inline">\(\mathbf{x}_i\)</span> etwas über <span class="math inline">\(y_i\)</span> lernen können. Wir nehmen ganz allgemein an, dass der Zusammenhang zwischen dem Output <span class="math inline">\(y_i\)</span> und den Input-Variablen <span class="math inline">\(\mathbf{x}_i\)</span> mathematisch wie folgt ausgedrückt werden kann <span class="citation" data-cites="islr">(<a href="references.html#ref-islr" role="doc-biblioref">James u.&nbsp;a. 2021, Kap. 2</a>)</span>:</p>
<p><span class="math display">\[
y_i = f(\mathbf{x}_i) + \epsilon
\]</span></p>
<ul>
<li>Die Funktion <span class="math inline">\(f(\mathbf{x}_i)\)</span> bezeichnet die <strong>systematische Information</strong>, die wir aus <span class="math inline">\(\mathbf{x}_i\)</span> im Hinblick auf <span class="math inline">\(y_i\)</span> lernen können. Oder in anderen Worten: <span class="math inline">\(f\)</span> mappt die Input-Werte <span class="math inline">\(\mathbf{x}_i\)</span> auf die Output-Werte <span class="math inline">\(y_i\)</span>.</li>
<li><span class="math inline">\(\epsilon\)</span> ist ein Fehlerterm, der die Differenz zwischen <span class="math inline">\(y_i\)</span> und <span class="math inline">\(f(\mathbf{x}_i)\)</span> abbildet,<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> also den <strong>nicht-lernbaren</strong> (unsystematischen) <strong>Teil</strong>. Der Fehlerterm beinhaltet einerseits den Effekt von Variablen, die uns nicht zur Verfügung stehen, aber einen Einfluss auf den Output <span class="math inline">\(y_i\)</span> haben und andererseits nicht-messbare Variation in <span class="math inline">\(y_i\)</span>, oft auch einfach <em>Noise</em> genannt. Grob gesagt: alles nicht-messbare. Auch wichtig zu sehen: der Fehler ist <strong>additiv</strong>, wir addieren ihn zum lernbaren Teil hinzu.</li>
</ul>
<p>Der Output <span class="math inline">\(y_i\)</span> ergibt sich also aus der Addition des systematischen Teils <span class="math inline">\(f(\mathbf{x}_i)\)</span> sowie des Fehlerterms <span class="math inline">\(\epsilon\)</span>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Hinweis</span>Ziel des Machine Learnings
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ziel des Machine Learnings ist es, eine Funktion <span class="math inline">\(\hat{f}(\mathbf{x}_i)\)</span> zu trainieren (schätzen), die der wahren aber unbekannten Funktion <span class="math inline">\(f(\mathbf{x}_i)\)</span> so nahe wie möglich kommt. Im (unrealistischen) Idealfall ist unser trainiertes Modell gleich der wahren Funktion, also <span class="math inline">\(\hat{f}(\mathbf{x}_i) = f(\mathbf{x}_i)\)</span> und wir haben die systematische Information perfekt gelernt.</p>
<p>Sobald wir <span class="math inline">\(\hat{f}(\mathbf{x}_i)\)</span> trainiert haben, können wir damit Vorhersagen machen, denn die Vorhersage für eine neue Beobachtung <span class="math inline">\(\mathbf{x}_0\)</span> ist nichts anderes als der Wert der trainierten Funktion an diesem Punkt, also <span class="math inline">\(\hat{y}_0 = \hat{f}(\mathbf{x}_0)\)</span>.</p>
<p>Jedes ML-Modell, das wir uns in diesem Buch anschauen werden, kann als eine mathematische Funktion <span class="math inline">\(\hat{f}(\mathbf{x}_i)\)</span> der Input-Variablen <span class="math inline">\(\mathbf{x}_i\)</span> aufgeschrieben werden.</p>
</div>
</div>
</section>
<section id="das-modell-ausgeschrieben" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="das-modell-ausgeschrieben"><span class="header-section-number">2.2</span> Das Modell (ausgeschrieben)</h2>
<p>Nun wollen wir uns konkret mit dem <strong>linearen Regressionsmodell</strong> befassen. Das bedeutet nun nichts anderes, als dass wir die allgemein geschriebene Funktion <span class="math inline">\(f(\mathbf{x}_i)\)</span> durch eine konkrete mathematische Funktion ersetzen. Im Machine Learning ist das der erste wichtige Schritt, nämlich die <strong>Modellwahl</strong> (engl. <em>Model Selection</em>). Das Modell kann wie folgt geschrieben werden:</p>
<p><span class="math display">\[
f(\mathbf{x}_i) = w_0 + w_1 \cdot x_{i1} + w_2 \cdot x_{i2} + \ldots + w_p \cdot x_{ip}
\]</span> Wir verzichten hier bewusst darauf, den Hut für <span class="math inline">\(f\)</span> zu schreiben, da es sich lediglich um eine allgemein gültige Funktion handelt und noch nichts geschätzt bzw. trainiert wurde. Dieses Modell bzw. diese Funktion hat sogenannte <strong>Parameter</strong>, die es zu schätzen gilt. Es handelt sich also auch hier um ein parametrisches Modell. Hier sind dies die Parameter <span class="math inline">\(w_0,\; w_1,\; \ldots,\; w_p\)</span>. Wegen der Konstante <span class="math inline">\(w_0\)</span> haben wir immer einen Parameter mehr als es Input-Variablen hat, also <span class="math inline">\(p+1\)</span> Parameter.</p>
<p>Diese Parameter sind die Schlüsselzutat in einem ML-Modell. Wir wollen sie <strong>optimieren</strong>, so dass die trainierte Funktion <span class="math inline">\(\hat{f}(\mathbf{x}_i)\)</span> der wahren Funktion <span class="math inline">\(f(\mathbf{x}_i)\)</span> möglichst nahe kommt und die beobachteten Daten möglichst gut beschreibt.</p>
<p>Wir schauen uns in diesem Kapitel ein ganz einfaches Beispiel mit nur <strong>einer Input-Variable</strong> <span class="math inline">\(x_i\)</span> an, so dass der Zusammenhang zwischen dem Output <span class="math inline">\(y_i\)</span> und dem Input <span class="math inline">\(x_i\)</span> in 2D dargestellt werden kann. In diesem Zusammenhang spricht man vom <strong>einfachen linearen Regressionsmodell</strong>. Ausserdem haben wir nur vier Beobachtungen, welche in folgender Abbildung in einem Streudiagramm dargestellt werden:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="02_linreg_files/figure-html/simple-reg-1.png" class="img-fluid figure-img" style="width:60.0%" alt="Einfaches Regressionsbeispiel."></p>
<figcaption>Einfaches Regressionsbeispiel. Die vier Beobachtungen werden in einem Streudiagramm dargestellt. Auf der x-Achse ist der Wert der Input-Variable und auf der y-Achse der Wert der Output-Variable ablesbar.</figcaption>
</figure>
</div>
</div>
</div>
<p>Obwohl obige Abbildung ähnlich aussieht wie die Abbildungen zum Perceptron, gibt es hier einen bedeutenden Unterschied. Auf der y-Achse des Streudiagramm wird der Outputwert der Beobachtungen dargestellt, während auf der x-Achse der Input-Wert angezeigt wird. Es wird nun darum gehen, eine <strong>Gerade</strong> zu finden, welche die vier Beobachtungen bestmöglich repräsentiert.</p>
</section>
<section id="das-modell-kompakt" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="das-modell-kompakt"><span class="header-section-number">2.3</span> Das Modell (kompakt)</h2>
<p>Sie haben oben gesehen, dass es ziemlich umständlich sein kann, das lineare Regressionsmodell aufzuschreiben, insbesondere wenn wir viele Input-Variablen haben. Mithilfe von <strong>Vektoren und Matrizen</strong> können wir das Modell viel kompakter aufschreiben.</p>
<p>Wir haben in <a href="01_intro.html" class="quarto-xref"><span>Kapitel 1</span></a> bereits gesehen, dass die Input-Variablen für eine Beobachtung <span class="math inline">\(i\)</span> als Spaltenvektor geschrieben werden können. Wir modifizieren diesen Spaltenvektor in einem ersten Schritt, indem wir an erster Stelle eine 1 einfügen,<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> also:</p>
<p><span class="math display">\[\mathbf{x}_i=\begin{pmatrix} 1\\ x_{i1} \\ x_{i2} \\ \vdots \\ x_{ip} \end{pmatrix}\]</span></p>
<p>Nun stecken wir die Parameter des Modells ebenfalls in einen Spaltenvektor:</p>
<p><span class="math display">\[\mathbf{w}=\begin{pmatrix} w_0 \\ w_1 \\ w_2 \\ \vdots \\ w_p \end{pmatrix}\]</span></p>
<p>Wie bereits für das Perceptron gesehen, können wir das lineare Regressionsmodell (für die Beobachtung <span class="math inline">\(i\)</span>) als <strong>Skalarprodukt</strong> dieser beiden Vektoren aufschreiben:</p>
<p><span class="math display">\[\begin{align}
f(\mathbf{x}_i) &amp;= \mathbf{w}' \mathbf{x_i}\\
&amp;= \begin{pmatrix} w_0 &amp; w_1 &amp; w_2 &amp; \dots &amp; w_p \end{pmatrix} \begin{pmatrix} 1\\ x_{i1} \\ x_{i2} \\ \vdots \\ x_{ip} \end{pmatrix}\\
&amp;= w_0 \cdot 1 + w_1 \cdot x_{i1} + w_2 \cdot x_{i2} + \dots + w_p \cdot x_{ip}
\end{align}\]</span></p>
<section id="frage" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="frage">Frage</h4>
<p>Doch Moment mal, das lineare Regressionsmodell sieht ja genau gleich wie ein Perceptron aus. Wie unterscheiden sich die beiden Modelle im Hinblick darauf, was mit <span class="math inline">\(\mathbf{w}' \mathbf{x_i}\)</span> gemacht wird?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tipp</span>Lösung
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Grundsätzlich gilt: das Perceptron ist ein Klassifikationsmodell, während das lineare Regressionsmodell zur Lösung von Regressionsproblemen dient.</p>
<p>Beim Perceptron haben wir <span class="math inline">\(\mathbf{w}' \mathbf{x_i}\)</span> verglichen mit dem Schwellenwert 0, um zu entscheiden, ob wir eine Beobachtung der Kategorie -1 oder +1 zuweisen.</p>
<p>Hier, beim linearen Regressionsmodell, soll <span class="math inline">\(\mathbf{w}' \mathbf{x_i}\)</span> den stetigen (numerischen) Outputwert <span class="math inline">\(y_i\)</span> möglichst gut abbilden.</p>
</div>
</div>
</div>
<p>Die Form <span class="math inline">\(\mathbf{w}' \mathbf{x_i}\)</span> ist schon ziemlich kompakt, aber es geht noch besser. Wir können nämlich das Modell gleich für alle <span class="math inline">\(n\)</span> Beobachtungen (und nicht nur für die <span class="math inline">\(i\)</span>-te Beobachtung) aufschreiben. Dazu müssen wir die Input-Variablen für jede Beobachtung <span class="math inline">\(i\)</span> in einer Matrix anordnen:</p>
<p><span class="math display">\[
\mathbf{X} = \begin{pmatrix}
1 &amp; x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p}\\
1 &amp; x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2p}\\
\vdots &amp; \cdots &amp; \cdots &amp; \ddots &amp; \vdots\\
1 &amp; x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{np}\\
\end{pmatrix}
\]</span></p>
<p>Die Matrix <span class="math inline">\(\mathbf{X}\)</span> wird typischerweise <strong>Design Matrix</strong> genannt. Die erste Zeile enthält die Input-Variablen für die erste Beobachtung, die zweite Zeile die Input-Variablen für die zweite Beobachtung, usw. Nun können wir das Modell mithilfe einer Multiplikation zwischen der Design Matrix <span class="math inline">\(\mathbf{X}\)</span> und dem Spaltenvektor <span class="math inline">\(\mathbf{w}\)</span> in einem Schritt für alle Beobachtungen aufschreiben:</p>
<p><span class="math display">\[\begin{align}
f(\mathbf{X}) &amp;= \mathbf{X}\mathbf{w}\\
&amp;= \begin{pmatrix}
1 &amp; x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p}\\
1 &amp; x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2p}\\
\vdots &amp; \cdots &amp; \cdots &amp; \ddots &amp; \vdots\\
1 &amp; x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{np}\\
\end{pmatrix}\begin{pmatrix} w_0 \\ w_1 \\ w_2 \\ \dots \\ w_p \end{pmatrix}\\
&amp;= \begin{pmatrix}
w_0 \cdot 1 + w_1 \cdot x_{11} + w_2 \cdot x_{12} + \dots + w_p \cdot x_{1p} \\
w_0 \cdot 1 + w_1 \cdot x_{21} + w_2 \cdot x_{22} + \dots + w_p \cdot x_{2p} \\
\cdots \\
w_0 \cdot 1 + w_1 \cdot x_{n1} + w_2 \cdot x_{n2} + \dots + w_p \cdot x_{np}\end{pmatrix}
\end{align}\]</span></p>
<p>Überprüfen wir doch noch kurz die Dimensionen von obigem Matrix-Vektor Produkt. Die Matrix <span class="math inline">\(\mathbf{X}\)</span> hat <span class="math inline">\(n\)</span> Zeilen und <span class="math inline">\(p+1\)</span> Spalten und darum eine Dimensionalität von <span class="math inline">\(n \times (p+1)\)</span>. Der Spaltenvektor <span class="math inline">\(\mathbf{w}\)</span> hat Dimensionalität <span class="math inline">\((p+1) \times 1\)</span>. Das Matrix-Vektor Produkt hat dementsprechend eine Dimensionalität von <span class="math inline">\(n \times 1\)</span>, genau was wir erwarten würden, nämlich einen (Spalten-)Vektor mit den Vorhersagen für alle <span class="math inline">\(n\)</span> Beobachtungen.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Vorsicht</span>Matrixprodukt
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Wenn das Produkt zweier Matrizen <span class="math inline">\(\mathbf{A}\)</span> und <span class="math inline">\(\mathbf{B}\)</span> gerechnet werden soll, dann gilt es immer zuerst die Dimensionen der beiden Matrizen zu prüfen. Warum? Die Multiplikation <span class="math inline">\(\mathbf{A}\mathbf{B}\)</span> funktioniert nämlich nur dann, wenn die Anzahl Spalten von <span class="math inline">\(\mathbf{A}\)</span> gleich der Anzahl Zeilen von <span class="math inline">\(\mathbf{B}\)</span> ist.</p>
<p>Nehmen wir an, dass <span class="math inline">\(\mathbf{A}\)</span> eine Dimensionalität von <span class="math inline">\(m \times n\)</span> hat (<span class="math inline">\(\mathbf{A}\)</span> hat also <span class="math inline">\(m\)</span> Zeilen und <span class="math inline">\(n\)</span> Spalten). Die Matrix <span class="math inline">\(\mathbf{B}\)</span> hat eine Dimensionalität von <span class="math inline">\(n \times p\)</span>.</p>
<p>In diesem Fall ist obige Bedingung schon mal erfüllt, denn die Anzahl Spalten von <span class="math inline">\(\mathbf{A}\)</span> (also <span class="math inline">\(n\)</span>) ist gleich der Anzahl Zeilen von <span class="math inline">\(\mathbf{B}\)</span>.</p>
<p>Weiter gilt, dass die resultierenden Matrix <span class="math inline">\(\mathbf{C}=\mathbf{A}\mathbf{B}\)</span> eine Dimensionalität von <span class="math inline">\(m \times p\)</span> hat.</p>
<p>Doch wie berechnet man die Element der resultierenden Matrix <span class="math inline">\(\mathbf{C}\)</span>?</p>
<p>Das erste Element links oben in der Matrix (man kann es als <span class="math inline">\(\mathbf{C}_{1,1}\)</span> beschreiben) ist die Summe über die elementweisen Multiplikationen der Element in der ersten Zeile von <span class="math inline">\(\mathbf{A}\)</span> und der ersten Spalte von <span class="math inline">\(\mathbf{B}\)</span>.</p>
<p>Oder allgemeiner: <span class="math inline">\(\mathbf{C}_{i,j} = \sum_{k=1}^n \mathbf{A}_{i,k} \cdot \mathbf{B}_{k,j}\)</span>.</p>
<p>Am einfachsten lässt sich das ganze an einem Beispiel anschauen:</p>
<p><span class="math display">\[\begin{align}
\begin{pmatrix}
2 &amp; -3 \\
1 &amp; 2
\end{pmatrix}
\begin{pmatrix}
1.3 &amp; -3 &amp; 0 \\
1 &amp; 0.5 &amp; 1
\end{pmatrix}
&amp;=
\begin{pmatrix}
2\cdot 1.3 + (-3)\cdot 1
&amp; 2\cdot (-3) + (-3)\cdot 0.5
&amp; 2\cdot 0 + (-3)\cdot 1
\\
1\cdot 1.3 + 2\cdot 1
&amp; 1\cdot (-3) + 2\cdot 0.5
&amp; 1\cdot 0 + 2\cdot 1
\end{pmatrix}\\
&amp;=
\begin{pmatrix}
-0.4 &amp; -7.5 &amp; -3 \\
3.3 &amp; -2 &amp; 2
\end{pmatrix}.
\end{align}\]</span></p>
</div>
</div>
</div>
<p>Für unser einfaches Beispiel kann das Modell wie folgt in Matrixform geschrieben werden:</p>
<p><span class="math display">\[\begin{align}
f(\mathbf{X}) &amp;= \mathbf{X}\mathbf{w}\\
&amp;= \begin{pmatrix}
1 &amp; -4.1 \\
1 &amp; -0.5 \\
1 &amp; 1.4 \\
1 &amp; 4.4 \\
\end{pmatrix}\begin{pmatrix} w_0 \\ w_1 \end{pmatrix}\\
&amp;= \begin{pmatrix}
w_0 \cdot 1 - w_1 \cdot 4.1 \\
w_0 \cdot 1 - w_1 \cdot 0.5 \\
w_0 \cdot 1 + w_1 \cdot 1.4 \\
w_0 \cdot 1 + w_1 \cdot 4.4 \end{pmatrix}
\end{align}\]</span></p>
<p>Warum wir all das tun, werden wir weiter unten sehen. Es wird unser Leben viel einfacher machen! Versuchen Sie diesen Abschnitt hier gut zu verstehen, so dass Sie sobald wie möglich mit der Matrixschreibweise von Modellen vertraut sind.</p>
</section>
</section>
<section id="modelltraining" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="modelltraining"><span class="header-section-number">2.4</span> Modelltraining</h2>
<p>Wir werden uns hier anschauen, wie für das Training (oft auch <em>Fitting</em> genannt) des linearen Regressionsmodells <strong>zwei verschiedene Perspektiven</strong> eingenommen werden können, welche am Schluss beide zum selben Resultat führen.</p>
<section id="perspektive-1-funktionsoptimierung" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="perspektive-1-funktionsoptimierung"><span class="header-section-number">2.4.1</span> Perspektive 1: Funktionsoptimierung</h3>
<p>In der ersten Perspektive behandeln wir das Modelltraining als Optimierungsproblem. Wir wollen nämlich eine sogenannte <strong>Kostenfunktion</strong> (engl. <em>Loss Function</em>) aufstellen, die es danach zu minimieren gilt. Sie werden gleich sehen, dass die Kostenfunktion für das lineare Regressionsmodell von den Modellparameter <span class="math inline">\(w_0,w_1,\dots,w_p\)</span> abhängt. Das Ziel wird also sein, die optimalen Werte für die Modellparameter zu finden, so dass die Kostenfunktion so klein wie möglich ist.</p>
<p>Doch wie sieht denn nun diese Kostenfunktion für das lineare Regressionsmodell konkret aus? Wir werden uns hier der Einfachheit halber nur ein <strong>einfaches lineares Regressionsmodell</strong> mit nur einer Input-Variable <span class="math inline">\(x_i\)</span> anschauen (wie in unserem einfachen Beispiel). Die Kostenfunktion sieht in diesem Fall so aus:</p>
<p><span class="math display">\[
J(\hat{w}_0,\hat{w}_1) = \frac{1}{2n} \sum_{i=1}^{n} \left(y_i - \hat{f}(x_i) \right)^2
\]</span></p>
<p>Sie sehen, dass die Kostenfunktion <span class="math inline">\(J(\hat{w}_0,\hat{w}_1)\)</span> eine Funktion der beiden (trainierten) Modellparameter ist. Vielleicht wundern Sie sich nun, wie diese Kostenfunktion von den Modellparameter abhängt, da diese in obiger Formel ja gar nicht direkt ersichtlich sind. Schreiben wir die Kostenfunktion doch mal etwas um:</p>
<p><span class="math display">\[\begin{align}
J(\hat{w}_0, \hat{w}_1) &amp;= \frac{1}{2n} \sum_{i=1}^{n} \left(y_i - \hat{f}(x_i) \right)^2 \\
&amp;= \frac{1}{2n} \sum_{i=1}^{n} \left(y_i - (\hat{w}_0 + \hat{w}_1 \cdot x_i) \right)^2 \\
&amp;= \frac{1}{2n} \sum_{i=1}^{n} \left(y_i - \hat{w}_0 - \hat{w}_1 \cdot x_i \right)^2 \\
\end{align}\]</span></p>
<p>Nun ist offensichtlich, wie die Kostenfunktion <span class="math inline">\(J\)</span> von den Modellparameter <span class="math inline">\(\hat{w}_0\)</span> und <span class="math inline">\(\hat{w}_1\)</span> abhängt. Im ML gibt es nun viele verschiedene Arten, wie man für die beiden Modellparameter die optimalen Werte findet. Hier ist die Lösung zum Glück einfach, denn es gibt eine sogenannte <strong>analytische Lösung</strong>, d.h. es ist möglich für <span class="math inline">\(\hat{w}_0\)</span> und <span class="math inline">\(\hat{w}_1\)</span> je eine Formel zu finden, die uns erlaubt die optimalen Parameterwerte direkt auszurechnen. Die Herleitung dieser Formeln ist nicht besonders schwierig, denn wir wenden nämlich ein altbekanntes Prinzip aus der <strong>Differenzialrechnung</strong> an: wir berechnen die erste Ableitung der Funktion nach den Modellparameter, setzen sie gleich Null und lösen nach dem Parameter auf.</p>
<p>Im folgenden Matheteil sehen Sie, wie wir die Formeln für die Berechnung der optimalen Parameterwerte des einfachen linearen Regressionsmodells herleiten können. Diese Methode wird <strong>Kleinstquadratemethode</strong> (engl. <em>Least Squares</em>) genannt, weil die optimalen Parameter die Summe über die <strong>quadrierten</strong> Differenzen zwischen <span class="math inline">\(y_i\)</span> und den Vorhersagen <span class="math inline">\(\hat{f}(x_i)\)</span> minimieren.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Vorsicht</span>Kleinstquadratemethode
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Wir leiten zuerst die Formel für <span class="math inline">\(\hat{w}_0\)</span> her:</p>
<p><span class="math display">\[\begin{align}
\frac{\partial J(\hat{w}_0, \hat{w}_1)}{\partial \hat{w}_0} &amp;= \frac{1}{2n} \sum_{i=1}^{n} 2 \cdot \left(y_i - \hat{w}_0 - \hat{w}_1 \cdot x_i \right) \cdot (-1) \\
&amp;= -\frac{1}{n} \sum_{i=1}^{n} \left(y_i - \hat{w}_0 - \hat{w}_1 \cdot x_i \right) \\
&amp;= -\frac{1}{n} \sum_{i=1}^{n} y_i +  \frac{1}{n} \sum_{i=1}^{n} \hat{w}_0 + \frac{1}{n} \sum_{i=1}^{n} \hat{w}_1 \cdot x_i \\
&amp;= -\bar{y} + \frac{1}{n} \cdot n \cdot \hat{w}_0 + \hat{w}_1 \cdot \bar{x} \\
&amp;= -\bar{y} + \hat{w}_0 + \hat{w}_1 \cdot \bar{x}
\end{align}\]</span></p>
<p>Nun setzten wir die Ableitung gleich Null und lösen nach <span class="math inline">\(\hat{w}_0\)</span> auf:</p>
<p><span class="math display">\[\begin{align}
-\bar{y} + \hat{w}_0 + \hat{w}_1 \cdot \bar{x} &amp;= 0 \\
\hat{w}_0 &amp;= \bar{y} - \hat{w}_1 \cdot \bar{x}
\end{align}\]</span></p>
<p>Wir sehen, dass die Lösung für <span class="math inline">\(\hat{w}_0\)</span> von den beiden Mittelwerten <span class="math inline">\(\bar{y}\)</span> und <span class="math inline">\(\bar{x}\)</span> sowie von <span class="math inline">\(\hat{w}_1\)</span> abhängt. Suchen wir nun also in einem zweiten Schritt die Lösung für <span class="math inline">\(\hat{w}_1\)</span>:</p>
<p><span class="math display">\[\begin{align}
\frac{\partial J(\hat{w}_0, \hat{w}_1)}{\partial \hat{w}_1} &amp;= \frac{1}{2n} \sum_{i=1}^{n} 2 \cdot \left(y_i - \hat{w}_0 - \hat{w}_1 \cdot x_i \right) \cdot (-x_i) \\
&amp;= -\frac{1}{n} \sum_{i=1}^{n} \left(y_i \cdot x_i - \hat{w}_0 \cdot x_i - \hat{w}_1 \cdot x_i^2 \right) \\
&amp;= -\frac{1}{n} \sum_{i=1}^{n} y_i \cdot x_i + \hat{w}_0 \cdot \frac{1}{n} \sum_{i=1}^{n} x_i + \hat{w}_1 \cdot \frac{1}{n} \sum_{i=1}^{n} x_i^2 \\
&amp;= -\frac{1}{n} \sum_{i=1}^{n} y_i \cdot x_i + \hat{w}_0 \cdot \bar{x} + \hat{w}_1 \cdot \frac{1}{n} \sum_{i=1}^{n} x_i^2 \\
\end{align}\]</span></p>
<p>Nun können wir wiederum die Ableitung gleich Null setzen und für <span class="math inline">\(\hat{w}_0\)</span> setzen wir unsere Lösung von oben ein. Danach lösen wir nach <span class="math inline">\(\hat{w}_1\)</span> auf:</p>
<p><span class="math display">\[\begin{align}
-\frac{1}{n} \sum_{i=1}^{n} y_i \cdot x_i + \hat{w}_0 \cdot \bar{x} + \hat{w}_1 \cdot \frac{1}{n} \sum_{i=1}^{n} x_i^2 &amp;= 0 \\
(\bar{y} - \hat{w}_1 \cdot \bar{x}) \cdot \bar{x} + \hat{w}_1 \cdot \frac{1}{n} \sum_{i=1}^{n} x_i^2 &amp;= \frac{1}{n} \sum_{i=1}^{n} y_i \cdot x_i \\
\bar{y} \cdot \bar{x} - \hat{w}_1 \cdot \bar{x}^2 + \hat{w}_1 \cdot \frac{1}{n} \sum_{i=1}^{n} x_i^2 &amp;= \frac{1}{n} \sum_{i=1}^{n} y_i \cdot x_i \\
\hat{w}_1 \left(\frac{1}{n} \sum_{i=1}^{n} x_i^2 - \bar{x}^2 \right) &amp;= \frac{1}{n} \sum_{i=1}^{n} y_i \cdot x_i - \bar{y} \cdot \bar{x} \\
\hat{w}_1 &amp;= \frac{\frac{1}{n} \sum_{i=1}^{n} y_i \cdot x_i - \bar{y} \cdot \bar{x}}{\frac{1}{n} \sum_{i=1}^{n} x_i^2 - \bar{x}^2}
\end{align}\]</span></p>
<p>Vielleicht erkennen Sie die Ausdrücke im Zähler und Nenner der Lösung für <span class="math inline">\(\hat{w}_1\)</span>: es sind dies die <strong>Kovarianz</strong> zwischen <span class="math inline">\(y_i\)</span> und <span class="math inline">\(x_i\)</span> im Zähler und die <strong>Varianz</strong> von <span class="math inline">\(x_i\)</span> im Nenner. Man kan die Formel also auch wie folgt aufschreiben:</p>
<p><span class="math display">\[
\hat{w}_1 = \frac{\text{Cov}(x, y)}{\text{Var}(x)}
\]</span></p>
</div>
</div>
</div>
<section id="frage-1" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="frage-1">Frage</h4>
<p>Rechnen Sie nun die optimalen Parameterwerte für unser einfaches lineares Regressionsmodell aus. Sie können die verschiedenen statistischen Grössen entweder mithilfe von R rechnen oder von Hand bzw. mit dem Taschenrechner.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tipp</span>Lösung
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Wir rechnen als erstes die Mittelwerte für die beiden Variablen:</p>
<p><span class="math display">\[
\bar{x} = \frac{-4.1 + (-0.5) + 1.4 + 4.4}{4} = 0.3
\]</span></p>
<p><span class="math display">\[
\bar{y} = \frac{3.50 + 1.95 + (-2.50) + (-2.05)}{4} = 0.225
\]</span></p>
<p>Danach rechnen wir die mittlere Summe über die Produkte der jeweiligen Variablenwerte (erster Teil des Zählers der Formel für <span class="math inline">\(\hat{w}_1\)</span>):</p>
<p><span class="math display">\[
\frac{3.50 \cdot (-4.1) + 1.95 \cdot (-0.5) + (-2.50) \cdot 1.4 + (-2.05) \cdot 4.4}{4}
= -6.96125
\]</span></p>
<p>Nun rechnen wir die mittlere Summe über die quadrierten <span class="math inline">\(x\)</span>-Werte (erster Teil des Nenners der Formel für <span class="math inline">\(\hat{w}_1\)</span>):</p>
<p><span class="math display">\[
\frac{(-4.1)^2 + (-0.5)^2 + 1.4^2 + 4.4^2}{4} = 9.595
\]</span></p>
<p>Nun können wir den optimalen Parameterwert für <span class="math inline">\(\hat{w}_1\)</span> berechnen:</p>
<p><span class="math display">\[
\hat{w}_1 = \frac{-6.96125 - 0.225 \cdot 0.3}{9.595 - 0.3^2} = -0.7395
\]</span></p>
<p>Und nun haben wir auch gleich alle Zutaten, um den optimalen Parameterwert für <span class="math inline">\(\hat{w}_0\)</span> zu berechnen:</p>
<p><span class="math display">\[
\hat{w}_0 = 0.225 - (-0.7395) \cdot 0.3 = 0.4469
\]</span></p>
<p>Unser trainiertes optimales Modell sieht also wie folgt aus:</p>
<p><span class="math display">\[
\hat{f}(x_i) = 0.4469 - 0.7395 \cdot x_i
\]</span></p>
</div>
</div>
</div>
<p>Das in der obigen Aufgabe berechnete Modell ist in der folgenden Abbildung (links) grafisch als blaue Gerade dargestellt. Der Parameter <span class="math inline">\(\hat{w}_0\)</span> ist der Ort, an dem die Gerade die y-Achse durchkreuzt, während der Parameter <span class="math inline">\(\hat{w}_1\)</span> der Steigung der Geraden entspricht. Unser optimales Modell minimiert die Summe über die quadrierten Differenzen zwischen den tatsächlichen <span class="math inline">\(y_i\)</span> Werten und den Vorhersagen gemäss unserem Modell <span class="math inline">\(\hat{f}(x_i)\)</span> (die Differenzen sind als rot gestrichelte Linien eingetragen).</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="02_linreg_files/figure-html/simple-reg-cost-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Einfaches Regressionsbeispiel."></p>
<figcaption>Einfaches Regressionsbeispiel. Das geschätzte Modell ist als blaue Gerade eingezeichnet. Die vertikalen roten Linien stellen die Abweichungen der wahren Outputs von den Vorhersagen dar. Rechts ist ein Konturplot der Kostenfunktion mit der optimalen Parameterwert-Kombination dargestellt.</figcaption>
</figure>
</div>
</div>
</div>
<p>Die Abbildung (rechts) zeigt sogennante <strong>Konturlinien</strong> unserer Kostenfunktion. Die optimale Parameterwert-Kombination ist als roter Punkt eingezeichnet. Jede Konturlinie zeigt alle Parameterwert-Kombination, welche jeweils zum gleichen Kostenwert führen. Die fünf eingezeichneten Linien zeigen beispielsweise die Parameterwert-Kombination für die Kostenwerte 1 bis 5 (von innen nach aussen). Man kann sich unsere Kostenfunktion also wie eine Schüssel vorstellen mit dem roten Punkt als Boden der Schüssel. Es handelt sich bei unserer Kostenfunktion um eine Funktion, die <strong>quadratisch</strong> in den Parameterwerten <span class="math inline">\(\hat{w}_0\)</span> und <span class="math inline">\(\hat{w}_1\)</span> ist. In diesem Fall finden wir immer <strong>genau eine Parameterwert-Kombination</strong>, welche dem absoluten Minimum der Kostenfunktion entspricht. Manchmal spricht man auch von einer <strong>konvexen</strong> Kostenfunktion.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Vorsicht</span>Kleinstquadratemethode in Matrixform (optional)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Die obige Herleitung funktioniert nur für das einfache lineare Regressionsmodell mit einer Input-Variable <span class="math inline">\(x_i\)</span>. Wir schauen uns hier nun kurz die allgemeine Lösung in Matrixform an. Wir nehmen an, dass die Werte unseres Outputs alle in einem Spaltenvektor <span class="math inline">\(\mathbf{y}\)</span> organisiert sind und unsere Modellvorhersagen als <span class="math inline">\(\mathbf{X}\mathbf{\hat{w}}\)</span> geschrieben werden können.</p>
<p>Dann können wir unsere Kostenfunktion von oben wie folgt in Matrixform schreiben:</p>
<p><span class="math display">\[\begin{align}
J(\mathbf{\hat{w}}) &amp;= \frac{1}{2n} (\mathbf{y} - \mathbf{X}\mathbf{\hat{w}})' (\mathbf{y} - \mathbf{X}\mathbf{\hat{w}})
\end{align}\]</span></p>
<p>Das sieht schlimmer aus als es ist, denn <span class="math inline">\((\mathbf{y} - \mathbf{X}\mathbf{\hat{w}})\)</span> ist lediglich ein Spaltenvektor mit den Differenzen zwischen den wahren <span class="math inline">\(y_i\)</span> und den Vorhersagen unseres Modells. Wenn wir diesen Spaltenvektor <span class="math inline">\(\mathbf{e}\)</span> nennen, dann kann obiger Ausdruck als <span class="math inline">\(\frac{1}{2n} \mathbf{e}'\mathbf{e}\)</span> geschrieben werden, wobei <span class="math inline">\(\mathbf{e}'\mathbf{e}\)</span> ein Skalarprodukt ist und dementsprechend einen Skalar bzw. eine einzige Zahl zurück gibt. Diese Zahl multipliziert mit <span class="math inline">\(\frac{1}{2n}\)</span> ist dann nichts anderes als der Wert unserer Kostenfunktion. Sie sehen also, dass wir mit dem Skalarprodukt <span class="math inline">\(\mathbf{e}'\mathbf{e}\)</span> die Summe ersetzen können.</p>
<p>Nun wenden wir die bekannten Matrix-Rechenregeln an, um die Kostenfunktion umzuschreiben:</p>
<p><span class="math display">\[\begin{align}
J(\mathbf{\hat{w}}) &amp;= \frac{1}{2n} (\mathbf{y} - \mathbf{X}\mathbf{\hat{w}})' (\mathbf{y} - \mathbf{X}\mathbf{\hat{w}}) \\
&amp;= \frac{1}{2n} (\mathbf{y}' - \mathbf{\hat{w}}' \mathbf{X}') (\mathbf{y} - \mathbf{X}\mathbf{\hat{w}}) \\
&amp;= \frac{1}{2n} (\mathbf{y}'\mathbf{y} - \mathbf{y}'\mathbf{X}\mathbf{\hat{w}} - \mathbf{\hat{w}}' \mathbf{X}'\mathbf{y} + \mathbf{\hat{w}}' \mathbf{X}'\mathbf{X}\mathbf{\hat{w}})
\end{align}\]</span></p>
<p>Wenn Sie sich kurz anhand der Dimensionalität der einzelnen Komponenten überlegen, was das Endprodukt des Ausdrucks <span class="math inline">\(\mathbf{y}'\mathbf{X}\mathbf{\hat{w}}\)</span> ist, dann werden Sie sehen, dass ein Skalar (Dimensionalität <span class="math inline">\(1 \times 1\)</span>) resultiert. Darum muss zwingend auch die transponierte Form davon, <span class="math inline">\((\mathbf{y}'\mathbf{X}\mathbf{\hat{w}})'=\mathbf{\hat{w}}' \mathbf{X}'\mathbf{y}\)</span> ein Skalar sein, was dazu führt, dass die beiden mittleren Terme in der letzten Zeile von obiger Kostenfunktion identisch sein müssen. Deshalb können wir die Kostenfunktion wie folgt umschreiben:</p>
<p><span class="math display">\[\begin{align}
J(\mathbf{\hat{w}}) &amp;= \frac{1}{2n} (\mathbf{y}'\mathbf{y} - 2\mathbf{y}'\mathbf{X}\mathbf{\hat{w}} + \mathbf{\hat{w}}' \mathbf{X}'\mathbf{X}\mathbf{\hat{w}})
\end{align}\]</span></p>
<p>So, nun können wir die Kostenfunktion nach dem Spaltenvektor mit den Modellparameter <span class="math inline">\(\mathbf{\hat{w}}\)</span> ableiten. Man spricht in diesem Fall nun nicht von einer Ableitung, sondern von einem <strong>Gradienten</strong>. Auch die mathematische Schreibweise ist etwas anders:</p>
<p><span class="math display">\[\begin{align}
\nabla_{\mathbf{\hat{w}}} J(\mathbf{\hat{w}}) &amp;= \frac{1}{2n} (- 2\mathbf{X}'\mathbf{y} + 2\mathbf{X}'\mathbf{X}\mathbf{\hat{w}}) \\
&amp;= \frac{1}{n} (-\mathbf{X}'\mathbf{y} + \mathbf{X}'\mathbf{X}\mathbf{\hat{w}})
\end{align}\]</span></p>
<p>Diesen Ausdruck können wir nun wie gewohnt gleich Null setzen (wobei wir hier rechts einen Nullvektor <span class="math inline">\(\mathbf{0}\)</span> setzen) und mit den Matrix-Rechenregeln nach <span class="math inline">\(\mathbf{\hat{w}}\)</span> auflösen:</p>
<p><span class="math display">\[\begin{align}
\frac{1}{n} (-\mathbf{X}'\mathbf{y} + \mathbf{X}'\mathbf{X}\mathbf{\hat{w}}) &amp;= \mathbf{0} \\
\mathbf{X}'\mathbf{X}\mathbf{\hat{w}} &amp;= \mathbf{X}'\mathbf{y} \\
\mathbf{\hat{w}} &amp;= (\mathbf{X}'\mathbf{X})^{-1}\mathbf{X}'\mathbf{y}
\end{align}\]</span></p>
<p><strong>Wichtig</strong>: Die Matrix <span class="math inline">\(\mathbf{X}'\mathbf{X}\)</span> hat eine Dimensionalität von <span class="math inline">\((p+1) \times (p+1)\)</span>, ist also quadratisch. Sie ist nur invertierbar, wenn die Design Matrix mehr Zeilen als Spalten hat, also wenn <span class="math inline">\(n &gt; (p+1)\)</span>.</p>
</div>
</div>
</div>
</section>
<section id="gütemasse-für-die-regression" class="level4">
<h4 class="anchored" data-anchor-id="gütemasse-für-die-regression">Gütemasse für die Regression</h4>
<p>Eine Form der hier verwendeten Kostenfunktion wird oft auch als Gütemass für die Vorhersagen eines Regressionsmodells verwendet. In diesem Zusammenhang sprechen wir dann vom <strong>Mean Squared Error</strong> (MSE). Mit diesen Gütemassen beurteilen wir die Vorhersagegüte von fertig trainierten Modellen; sie haben also nichts mit dem Training zu tun.</p>
<p>Häufig wird nicht der MSE sondern der <strong>Root Mean Squared Error</strong> (RMSE) verwendet, so dass das resultierende Fehlermass auf derselben Skala wie die Vorhersagen “lebt”. Oder anders gesagt, wir neutralisieren den Effekt des Quadrierens wieder. Die Formel für den RMSE sieht wie folgt aus:</p>
<p><span class="math display">\[
RMSE = \sqrt{\frac{1}{n} \sum_{i=1}^{n} \left(y_i - \hat{f}(x_i) \right)^2}
\]</span></p>
<p>Eine Alternative zum RMSE ist der <strong>Mean Absolute Error</strong> (MAE), der wie folgt definiert ist:</p>
<p><span class="math display">\[
MAE = \frac{1}{n} \sum_{i=1}^{n} |y_i - \hat{f}(x_i)|
\]</span> Der MAE hat im Vergleich zum RMSE den Vorteil, dass er wengier stark auf grosse Differenzen zwischen dem wahren und vorhergesagten Wert für <span class="math inline">\(y\)</span> reagiert, oder, in anderen Worten, robuster gegen Ausreisser ist.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
</section>
</section>
<section id="perspektive-2-wahrscheinlichkeitstheorie" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2" class="anchored" data-anchor-id="perspektive-2-wahrscheinlichkeitstheorie"><span class="header-section-number">2.4.2</span> Perspektive 2: Wahrscheinlichkeitstheorie</h3>
<p>Nun werden wir sehen, dass wir die Lösung oben (aus Perspektive 1) auch mit einer probabilistischen Sicht auf die Dinge erhalten. Dazu schreiben wir nochmals kurz den allgemein angenommenen Zusammenhang zwischen dem wahren Output <span class="math inline">\(y_i\)</span> und den Input-Variablen auf und konkretisieren ihn dann gleich für das lineare Regressionsmodell:</p>
<p><span class="math display">\[\begin{align}
y_i &amp;= f(\mathbf{x}_i) + \epsilon \\
&amp;= \mathbf{w}' \mathbf{x_i} + \epsilon \\
\end{align}\]</span></p>
<p>Nun nehmen wir an, dass der Fehlerterm <span class="math inline">\(\epsilon\)</span> normalverteilt ist mit Mittelwert 0 und Varianz <span class="math inline">\(\sigma^2\)</span>, also <span class="math inline">\(\epsilon \sim N(0,\sigma^2)\)</span>. Weil wir annehmen, dass <span class="math inline">\(\mathbf{w}' \mathbf{x_i}\)</span> fix ist (also keine Zufallsvariable), ist unser Output <span class="math inline">\(y_i\)</span> normalverteilt mit Mittelwert <span class="math inline">\(\mathbf{w}' \mathbf{x_i}\)</span> und Varianz <span class="math inline">\(\sigma^2\)</span>:</p>
<p><span class="math display">\[
y_i \sim \mathcal{N}\left(\mathbf{w}' \mathbf{x_i}, \sigma^2\right)
\]</span></p>
<p>Folgende Abbildung illlustriert diese Annahme: an jedem Ort <span class="math inline">\(x_i\)</span> ist der entsprechende Outputwert <span class="math inline">\(y_i\)</span> eine Realisierung (oder Ziehung) aus einer Normalverteilung mit Mittelwert <span class="math inline">\(\mathbf{w}' \mathbf{x_i}\)</span> und Varianz <span class="math inline">\(\sigma^2\)</span>.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="02_linreg_files/figure-html/simple-reg-maxlik-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%" alt="Einfaches Regressionsbeispiel."></p>
</figure>
</div>
</div>
</div>
<p>Nun möchten wir wissen, was die <strong>gemeinsame Verteilung</strong> aller Output-Werte in unserem Datensatz ist. D.h. wie sieht die Wahrscheinlichkeit <span class="math inline">\(p(y_1,y_2,\dots,y_n|\mathbf{w},\mathbf{X},\sigma^2)\)</span> aus? Weil wir annehmen, dass alle Beobachtungen <span class="math inline">\(i\)</span> in unserem Datensatz <strong>unabhängig</strong> sind und die Wahrscheinlichkeiten der einzelnen Beobachtungen <span class="math inline">\(i\)</span> darum multipliziert werden können, sieht die Antwort auf die Frage folgendermassen aus:</p>
<p><span class="math display">\[
p(y_1,y_2,\dots,y_n\mid\mathbf{w},\mathbf{X},\sigma^2) = \prod_{i=1}^n \mathcal{N}\left(\mathbf{w}' \mathbf{x_i}, \sigma^2\right)
\]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Hinweis</span>Maximum Likelihood
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die gemeinsame Wahrscheinlichkeit <span class="math inline">\(p(y_1,y_2,\dots,y_n\mid\mathbf{w},\mathbf{X},\sigma^2)\)</span> der beobachteten Output-Werte, gegeben die Input-Werte und das Modell (charakterisiert durch dessen Parameter <span class="math inline">\(\mathbf{w}\)</span> und <span class="math inline">\(\sigma^2\)</span>), wird in der Fachsprache <strong>Likelihood</strong> genannt.</p>
<p>Die zentrale Idee hier ist, dass wir die Modellparameter <span class="math inline">\(\mathbf{w}\)</span> so wählen, dass die <em>Likelihood</em> maximal wird. Der daraus folgende Ausdruck für <span class="math inline">\(\mathbf{w}\)</span> wird <strong>Maximum Likelihood</strong> Schätzer genannt und oft als ML abgekürzt, was sehr verwirrlich sein kann, da wir ja auch Machine Learning so abkürzen.</p>
<p>Mit dem ML-Schätzer finden wir also dasjenige (lineare) Modell (bzw. dessen Parameterwerte), das die beobachteten <span class="math inline">\(y_i\)</span>-Werte maximal wahrscheinlich macht.</p>
</div>
</div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Vorsicht</span>Maximum Likelihood Herleitung (optional)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Wir können nun in der Likelihood oben anstelle von <span class="math inline">\(\mathcal{N}\left(\mathbf{w}' \mathbf{x_i}, \sigma^2\right)\)</span> jeweils die Dichtefunktion der Normalverteilung einsetzen:</p>
<p><span class="math display">\[\begin{align}
p(y_1,y_2,\dots,y_n|\mathbf{w},\mathbf{X},\sigma^2) &amp;= \prod_{i=1}^n \mathcal{N}\left(\mathbf{w}' \mathbf{x_i}, \sigma^2\right) \\
&amp;= \prod_{i=1}^n \frac{1}{\sigma\sqrt{2\pi}} \exp\left( -\frac{1}{2}\left(\frac{y_i - \mathbf{w}' \mathbf{x_i}}{\sigma}\right)^{\!2}\,\right)
\end{align}\]</span></p>
<p>Nun vollziehen wir einen kleinen mathematischen Trick, der vielfach angewendet wird: anstelle der <em>Likelihood</em> verwenden wir nun den natürlichen Logarithmus der <em>Likelihood</em> (<em>Log-Likelihood</em>). Das ist möglich, weil sich so das Optimierungsproblem nicht verändert. Das Logarithmieren vereinfacht das Problem ungemein, denn der Logarithmus eines Produkts wird zu einer Summe der logarithmierten Elemente:</p>
<p><span class="math display">\[\begin{align}
\text{ln}\; p(y_1,y_2,\dots,y_n|\mathbf{w},\mathbf{X},\sigma^2) &amp;= \text{ln}\left(\prod_{i=1}^n \frac{1}{\sigma\sqrt{2\pi}} \exp\left( -\frac{1}{2}\left(\frac{y_i - \mathbf{w}' \mathbf{x_i}}{\sigma}\right)^{\!2}\,\right)\right) \\
&amp;= \sum_{i=1}^n \text{ln}\left(\frac{1}{\sigma\sqrt{2\pi}} \exp\left( -\frac{1}{2}\left(\frac{y_i - \mathbf{w}' \mathbf{x_i}}{\sigma}\right)^{\!2}\,\right) \right) \\
&amp;= \sum_{i=1}^n \text{ln}\left(1\right) - \text{ln}\left(\sigma\sqrt{2\pi}\right) - \frac{1}{2}\left(\frac{y_i - \mathbf{w}' \mathbf{x_i}}{\sigma}\right)^{\!2} \\
&amp;= \sum_{i=1}^n \text{ln}\left(1\right) - \sum_{i=1}^n \text{ln}\left(\sigma\sqrt{2\pi}\right) - \sum_{i=1}^n \frac{1}{2}\left(\frac{y_i - \mathbf{w}' \mathbf{x_i}}{\sigma}\right)^{\!2} \\
&amp;= n \cdot \text{ln}\left(1\right) - n \cdot \text{ln}\left(\sigma\sqrt{2\pi}\right) - \frac{1}{2\sigma^2} \sum_{i=1}^n \left(y_i - \mathbf{w}' \mathbf{x_i}\right)^{\!2}
\end{align}\]</span></p>
<p>Wow, nun haben wir ein tolles Resultat gefunden: je kleiner der Term <span class="math inline">\(\sum_{i=1}^n \left(y_i - \mathbf{w}' \mathbf{x_i}\right)^{\!2}\)</span> in obiger Gleichung, desto grösser ist der natürliche Logarithmus der <em>Likelihood</em>. Das heisst nichts anderes, als dass die Kleinstquadratemethode auch der <em>Maximum Likelihood</em> Schätzer ist.</p>
<p>Wir haben mit der Annahme begonnen, dass unser Output <span class="math inline">\(y_i\)</span> normalverteilt ist, d.h. <span class="math inline">\(y_i \sim \mathcal{N}\left(\mathbf{w}' \mathbf{x_i}, \sigma^2\right)\)</span>. Wir haben nun herausgefunden, dass der mit der Kleinstquadratemethode berechnete Vektor <span class="math inline">\(\mathbf{w}\)</span> auch glech dem ML-Schätzer entspricht. Um die Normalverteilung vollkommen zu spezifizieren, benötigen wir nun noch eine Formel, um die Varianz <span class="math inline">\(\sigma^2\)</span> zu rechnen. Dazu leiten wir den obigen Ausdruck der <em>Log-Likelihood</em> nach <span class="math inline">\(\sigma\)</span> ab:</p>
<p><span class="math display">\[\begin{align}
\frac{\partial \text{ln}\; p(y_1,y_2,\dots,y_n|\mathbf{w},\mathbf{X},\sigma^2)}{\partial \sigma} &amp;= -n\cdot \frac{\sqrt{2\pi}}{\sigma\sqrt{2\pi}} - (-\frac{2}{\sigma^3}) \cdot \frac{1}{2} \sum_{i=1}^n \left(y_i - \mathbf{w}' \mathbf{x_i}\right)^{\!2} \\
&amp;= -\frac{n}{\sigma} + \frac{1}{\sigma^3} \sum_{i=1}^n \left(y_i - \mathbf{w}' \mathbf{x_i}\right)^{\!2}
\end{align}\]</span></p>
<p>Nun können wir wie gewohnt die Ableitung gleich Null setzen und nach <span class="math inline">\(\sigma\)</span> auflösen:</p>
<p><span class="math display">\[\begin{align}
-\frac{n}{\hat{\sigma}} + \frac{1}{\hat{\sigma}^3} \sum_{i=1}^n \left(y_i - \mathbf{\hat{w}}' \mathbf{x_i}\right)^{\!2} &amp;= 0 \\
\frac{n}{\hat{\sigma}} &amp;= \frac{1}{\hat{\sigma}^3} \sum_{i=1}^n \left(y_i - \mathbf{\hat{w}}' \mathbf{x_i}\right)^{\!2} \\
\frac{\hat{\sigma}^3}{\hat{\sigma}} &amp;= \frac{1}{n} \sum_{i=1}^n \left(y_i - \mathbf{\hat{w}}' \mathbf{x_i}\right)^{\!2} \\
\hat{\sigma}^2 &amp;= \frac{1}{n} \sum_{i=1}^n \left(y_i - \mathbf{\hat{w}}' \mathbf{x_i}\right)^{\!2} \\
\end{align}\]</span></p>
<p>Sehr schön, dieses Resultat macht ebenfalls viel Sinn. Die geschätzte Varianz <span class="math inline">\(\hat{\sigma}^2\)</span> ist nichts anderes als der durchschnittliche quadrierte Fehler (engl. <em>Mean Squared Error</em>).</p>
</div>
</div>
</div>
<!-- Was heisst das auf unser kleines Beispiel übertragen? Der oben gefundene Kleinstquadrateschätzer $\mathbf{w}=\begin{pmatrix}0.4469 & -0.7395\end{pmatrix}'$ ist auch gleich der ML-Schätzer. Zusätzlich können wir mit dieser zweiten Perspektive eine Schätzung über die Unsicherheit vornehmen, und zwar indem wir den ML-Schätzer für $\sigma^2$ auf unser Beispiel anwenden: -->
<!-- \begin{align} -->
<!-- \hat{\sigma}^2 &= \frac{1}{n} \sum_{i=1}^n \left(y_i - \mathbf{\hat{w}}' \mathbf{x_i}\right)^{\!2}\\ -->
<!-- &= \frac{1}{4}((3.5 - 3.48)^2 + (1.95 - 0.82)^2 + (-2.5 - (-0.59))^2 + (-2.05 - (-2.81))^2)\\ -->
<!-- &= 1.37801 -->
<!-- \end{align}  -->
</section>
</section>
<section id="regularisierte-regression" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="regularisierte-regression"><span class="header-section-number">2.5</span> Regularisierte Regression</h2>
<p>Das zentrale Problem der oben kennen gelernten Kleinstquadratemethode ist, dass sie extrem anfällig auf <strong>Overfitting</strong> ist. Vereinfacht gesagt bedeutet Overfitting, dass sich das Modell zu fest an die Trainingsdaten anpasst und die aus den Daten gelernten Muster <strong>nicht mehr generalisierbar</strong> sind.</p>
<p>Beim linearen Regressionsmodell ist Overfitting vor allem dann ein Problem, wenn die Anzahl Input-Variablen <span class="math inline">\(p\)</span> relativ gross ist im Vergleich zur Anzahl Beobachtungen <span class="math inline">\(n\)</span>. Im Extremfall haben wir mehr Input-Variablen als Beobachtungen (<span class="math inline">\((p+1)&gt;n\)</span>), was dazu führt, dass der Kleinstquadrateschätzer mathematisch nicht rechenbar ist.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> Das sollte auch intuitiv Sinn machen, denn wie soll eine Schätzung funktionieren, wenn wir im Schnitt weniger als eine Beobachtung pro zu schätzenden Parameter haben.</p>
<p>Wir können das Problem des Overfittings weitgehend lösen, indem wir ein <strong>regularisiertes</strong> Regressionsmodell rechnen. Regularisierung bedeutet eigentlich nichts anderes, als dass wir die ursprüngliche Kostenfunktion für das lineare Regressionsmodell modifizieren. Dabei gibt es zwei bekannte Regularisierungsarten, nämlich <strong>Ridge</strong> oder <strong>LASSO</strong>. Wir fokussieren in einem ersten Schritt auf die Ridge Regularisierung, weil wir in diesem Fall wiederum eine analytische Lösung finden.</p>
<section id="ridge-regressionsmodell" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1" class="anchored" data-anchor-id="ridge-regressionsmodell"><span class="header-section-number">2.5.1</span> Ridge Regressionsmodell</h3>
<p>Die Kostenfunktion für das Ridge Regressionsmodell sieht wie folgt aus:</p>
<p><span class="math display">\[
J(\mathbf{w}) = \frac{1}{2n} \sum_{i=1}^{n} \left(y_i - \hat{f}(\mathbf{x}_i) \right)^2 + \frac{\lambda}{2} \cdot \sum_{j=1}^p w_j^2
\]</span></p>
<p>Diese modifizierte Kostenfunktion hat etwas Erklärungsbedarf:</p>
<ul>
<li>Wir versuchen hier Modellparameter <span class="math inline">\(\mathbf{w}\)</span> zu finden, welche <strong>gleichzeitig</strong> den durchschnittlichen quadrierten Fehler sowie eine Summe über die quadrierten Modellparameter so klein wie möglich machen. Das sind zwei <strong>konkurrenzierende Ziele</strong> und während des Modelltrainings muss der beste Tradeoff gefunden werden.</li>
<li>Der Regularisierungsterm ist eine Summe über die quadrierten Modellparameter. Das Quadrieren stellt sicher, dass sich positive und negative Parameterwerte nicht gegenseitig kompensieren.</li>
<li>Der <strong>Hyperparameter</strong> <span class="math inline">\(\lambda\)</span> legt fest, wie viel (relatives) Gewicht der Regularisierungsterm im Verhältnis zum durchschnittlichen quadrierten Fehler bekommt. Je grösser <span class="math inline">\(\lambda\)</span>, desto stärker “bestrafen” wir komplexe Modelle. Wir werden später sehen, wir wir den optimalen Wert für <span class="math inline">\(\lambda\)</span> via <strong>Cross-Validation</strong> finden können.</li>
<li>Der Regularisierungsterm enthält die Konstante <span class="math inline">\(w_0\)</span> <strong>nicht</strong> (die Summe startet bei <span class="math inline">\(j=1\)</span> und nicht bei <span class="math inline">\(j=0\)</span>). Die Konstante des Modells wird also nie regularisiert, denn sie definiert lediglich den Punkt, wo die Gerade (oder die Hyperebene im Fall von mehr als einer Input-Variable) die y-Achse schneidet. Dieser Parameter soll flexibel bleiben.</li>
</ul>
<section id="fragen" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="fragen">Fragen</h4>
<ul>
<li>Was passiert wenn <span class="math inline">\(\lambda=0\)</span>?</li>
<li>Was passiert wenn <span class="math inline">\(\lambda \rightarrow \infty\)</span>?</li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tipp</span>Lösung
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ul>
<li>Wenn <span class="math inline">\(\lambda=0\)</span>, dann entfällt der Regularisierungsterm und wir haben die altbekannte Kostenfunktion. Die resultierenden Parameter entsprechen dem Kleinstquadrateschätzer.</li>
<li>Wenn <span class="math inline">\(\lambda \rightarrow \infty\)</span>, dann wird der Regularisierungsterm so wichtig, dass alle Gewichte <span class="math inline">\(w_1,\dots, w_p\)</span> auf 0 gesetzt werden. Es resultiert folgendes Modell: <span class="math inline">\(\hat{f}(\mathbf{x_i}) = \hat{w}_0\)</span>.</li>
</ul>
</div>
</div>
</div>
<p>Berechnen Sie hier nun den optimalen Parameter <span class="math inline">\(\hat{w}_1\)</span> für ein einfaches regularisiertes Regressionsmodell mit nur einer <span class="math inline">\(x_i\)</span>-Variable.</p>
<ul>
<li>Leiten Sie dazu die obige Kostenfunktion nach <span class="math inline">\(\hat{w}_1\)</span> ab, setzen Sie sie gleich Null und lösen Sie nach <span class="math inline">\(\hat{w}_1\)</span> auf.</li>
<li>Für <span class="math inline">\(\hat{w}_0\)</span> können Sie die Lösung aus dem unregularisierten Fall einsetzen, also <span class="math inline">\(\hat{w}_0 = \bar{y} - \hat{w}_1 \cdot \bar{x}\)</span>.</li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tipp</span>Lösung
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Die Kostenfunktion für das einfache regularisierte Modell sieht konkret wie folgt aus:</p>
<p><span class="math display">\[
\begin{aligned}
J(\hat{w}_0, \hat{w}_1) &amp;= \frac{1}{2n} \sum_{i=1}^{n} \left(y_i - \hat{w}_0 - \hat{w}_1 \cdot x_i \right)^2 + \frac{\lambda}{2} \hat{w}_1^2
\end{aligned}
\]</span></p>
<p>Nun leiten wir diese Kostenfunktion nach <span class="math inline">\(\hat{w}_1\)</span> ab und gehen durch sehr ähnliche Schritte wie im unregularisierten Fall:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial J(\hat{w}_0, \hat{w}_1)}{\partial \hat{w}_1} &amp;= \frac{1}{2n} \sum_{i=1}^{n} 2 \cdot \left(y_i - \hat{w}_0 - \hat{w}_1 \cdot x_i \right) \cdot (-x_i) + \frac{2\lambda}{2} \hat{w}_1 \\[6pt]
&amp;= -\frac{1}{n} \sum_{i=1}^{n} \left(y_i x_i - \hat{w}_0 x_i - \hat{w}_1 x_i^2 \right) + \lambda \hat{w}_1 \\[6pt]
&amp;= -\frac{1}{n} \sum_{i=1}^{n} y_i x_i + \hat{w}_0 \bar{x} + \hat{w}_1 \cdot \frac{1}{n} \sum_{i=1}^{n} x_i^2 + \lambda \hat{w}_1 \\[6pt]
&amp;= -\frac{1}{n} \sum_{i=1}^{n} y_i x_i + (\bar{y} - \hat{w}_1 \bar{x}) \cdot \bar{x} + \hat{w}_1 \cdot \frac{1}{n} \sum_{i=1}^{n} x_i^2 + \lambda \hat{w}_1 \\[6pt]
&amp;= -\frac{1}{n} \sum_{i=1}^{n} y_i x_i + \bar{y}\bar{x} - \hat{w}_1 \bar{x}^2 + \hat{w}_1 \cdot \frac{1}{n} \sum_{i=1}^{n} x_i^2 + \lambda \hat{w}_1
\end{aligned}
\]</span></p>
<p>Nun setzen wir die Ableitung gleich Null und lösen nach <span class="math inline">\(\hat{w}_1\)</span> auf:</p>
<p><span class="math display">\[
\begin{aligned}
-\frac{1}{n} \sum_{i=1}^{n} y_i x_i + \bar{y}\bar{x} - \hat{w}_1 \bar{x}^2 + \hat{w}_1 \cdot \frac{1}{n} \sum_{i=1}^{n} x_i^2 + \lambda \hat{w}_1 &amp;= 0 \\[6pt]
-\hat{w}_1 \bar{x}^2 + \hat{w}_1 \cdot \frac{1}{n} \sum_{i=1}^{n} x_i^2 + \lambda \hat{w}_1 &amp;= \frac{1}{n} \sum_{i=1}^{n} y_i x_i - \bar{y}\bar{x} \\[6pt]
\hat{w}_1 \left( \frac{1}{n} \sum_{i=1}^{n} x_i^2 - \bar{x}^2 + \lambda \right) &amp;= \frac{1}{n} \sum_{i=1}^{n} y_i x_i - \bar{y}\bar{x} \\[6pt]
\hat{w}_1 &amp;= \frac{\mathrm{Cov}(y,x)}{\mathrm{Var}(x) + \lambda}
\end{aligned}
\]</span></p>
<p>Ha, das macht ja irgendwie Sinn. Je größer der Wert für <span class="math inline">\(\lambda\)</span>, desto grösser der Nenner und desto stärker wird der trainierte Wert für <span class="math inline">\(\hat{w}_1\)</span> beschränkt.</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-11-contents" aria-controls="callout-11" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Vorsicht</span>Ridge Regression in Matrixform (optional)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-11" class="callout-11-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Der Einfachheit halber nehmen wir hier an, dass die Outputwerte <span class="math inline">\(y_i\)</span> hier standardisiert<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> wurden, so dass der Mittelwert über die standardisierten Outputwerte Null ist. So entfällt die Konstante <span class="math inline">\(w_0\)</span> aus dem Modell, was uns die Matrixform für das Ridge Modell erleichtert, denn der Regularisierungsterm soll ja die Konstante nicht enthalten und wenn es diese nicht gibt, dann gibt es keine Probleme.</p>
<p>Wie weiter oben gesehen, können wir die Kostenfunktion für das nicht-regularisierte Modell wie folgt schreiben:</p>
<p><span class="math display">\[\begin{align}
J(\mathbf{\hat{w}}) &amp;= \frac{1}{2n} (\mathbf{y}'\mathbf{y} - 2\mathbf{y}'\mathbf{X}\mathbf{\hat{w}} + \mathbf{\hat{w}}' \mathbf{X}'\mathbf{X}\mathbf{\hat{w}})
\end{align}\]</span></p>
<p>Der Regularisierungsterm kann sehr einfach in Matrixform geschrieben werden, nämlich als Skalarprodukt <span class="math inline">\(\frac{\lambda}{2}\mathbf{\hat{w}}'\mathbf{\hat{w}}\)</span>. Damit kriegen wir folgende Kostenfunktion:</p>
<p><span class="math display">\[\begin{align}
J(\mathbf{\hat{w}}) &amp;= \frac{1}{2n} (\mathbf{y}'\mathbf{y} - 2\mathbf{y}'\mathbf{X}\mathbf{\hat{w}} + \mathbf{\hat{w}}' \mathbf{X}'\mathbf{X}\mathbf{\hat{w}}) + \frac{\lambda}{2}\mathbf{\hat{w}}'\mathbf{\hat{w}}
\end{align}\]</span></p>
<p>Um den Gradienten dieser Kostenfunktion zu finden, gehen wir nun sehr ähnlich wie oben vor:</p>
<p><span class="math display">\[\begin{align}
\nabla_{\mathbf{\hat{w}}} J(\mathbf{\hat{w}}) &amp;= \frac{1}{2n} (- 2\mathbf{X}'\mathbf{y} + 2\mathbf{X}'\mathbf{X}\mathbf{\hat{w}}) + \frac{2\lambda}{2}\mathbf{\hat{w}} \\
&amp;= \frac{1}{n} (-\mathbf{X}'\mathbf{y} + \mathbf{X}'\mathbf{X}\mathbf{\hat{w}}) + \lambda \mathbf{\hat{w}}
\end{align}\]</span></p>
<p>Diesen Ausdruck können wir nun wie gewohnt gleich Null setzen und mit den Matrix-Rechenregeln nach <span class="math inline">\(\mathbf{\hat{w}}\)</span> auflösen:</p>
<p><span class="math display">\[\begin{align}
\frac{1}{n} (-\mathbf{X}'\mathbf{y} + \mathbf{X}'\mathbf{X}\mathbf{\hat{w}}) + \lambda \mathbf{\hat{w}} &amp;= \mathbf{0} \\
\mathbf{X}'\mathbf{X}\mathbf{\hat{w}} + \lambda \mathbf{\hat{w}} &amp;= \mathbf{X}'\mathbf{y} \\
(\mathbf{X}'\mathbf{X} + \lambda \mathbf{I}) \mathbf{\hat{w}} &amp;= \mathbf{X}'\mathbf{y} \\
\mathbf{\hat{w}} &amp;= (\mathbf{X}'\mathbf{X} + \lambda \mathbf{I})^{-1}\mathbf{X}'\mathbf{y} \\
\end{align}\]</span></p>
<p><strong>Wichtig</strong>: <span class="math inline">\((\mathbf{X}'\mathbf{X} + \lambda \mathbf{I})\)</span> ist immer invertierbar, auch wenn <span class="math inline">\(p&gt;n\)</span>. Wir haben nun also ein analytisch lösbares Regressionsmodell gefunden, dass gut gegen Overfitting schützt.</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Hinweis</span>Standardisierung der Input-Variablen
</div>
</div>
<div class="callout-body-container callout-body">
<p>Es ist eminent wichtig, dass Sie <strong>alle numerischen Input-Variablen</strong> vor der Anwendung eines regularisierten Modells <strong>standardisieren</strong>, so dass alle Variablen auf der selben Skala “leben”. Warum ist das so wichtig? Sie haben gesehen, dass wir beim Ridge Modell die Grösse der Parameter mit dem Regularisierungsterm beschränken. Wenn jedoch die Input-Variablen alle auf unterschiedlichen Skalen “leben”, dann sind die Parameter nur schon deshalb unterschiedlich. Durch die Standardisierung der Input-Variablen erreichen wir, dass die Parametergrössen vergleichbar werden und die Regularisierung so auch korrekt funktioniert.</p>
</div>
</div>
</section>
</section>
<section id="lasso-regressionsmodell" class="level3" data-number="2.5.2">
<h3 data-number="2.5.2" class="anchored" data-anchor-id="lasso-regressionsmodell"><span class="header-section-number">2.5.2</span> LASSO Regressionsmodell</h3>
<p>Beim LASSO<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> Modell verwenden wir einen anderen Regularisierungsterm als bei Ridge. Anstatt die Parameter zu quadrieren (um Kompensationseffekte zu vermeiden), verwenden wir den <strong>absoluten Wert</strong>, d.h. wir ignorieren die Vorzeichen der Parameter:</p>
<p><span class="math display">\[
J(\mathbf{w}) = \frac{1}{2n} \sum_{i=1}^{n} \left(y_i - \hat{f}(\mathbf{x}_i) \right)^2 + \lambda \cdot \sum_{j=1}^p |w_j|
\]</span></p>
<p>Die Optimierung der LASSO Kostenfunktion hat allerdings einen gewichtigen <strong>Vorteil</strong> gegenüber Ridge, der nicht so offensichtlich ist: unwichtige Parameter werden bei LASSO auf 0 gesetzt, während Ridge die Parameter einfach kleiner macht, sie aber nie auf genau 0 setzt (ausser wenn <span class="math inline">\(\lambda \to \infty\)</span>). Das Modell nimmt also selbständig eine <strong>Selektion der wichtigen Variablen</strong> vor. Diese Eigenschaft macht das Modell auch gut interpretierbar, weil bei korrekter Anwendung von LASSE nur die relevanten Input-Variablen im Modell verbleiben.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-13-contents" aria-controls="callout-13" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Vorsicht</span>Wie funktioniert diese Variablenselektion bei LASSO? (optional)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-13" class="callout-13-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Um besser zu verstehen, warum LASSO eine automatische Variablenselektion vornimmt und die Modellparameter unwichtiger Input-Variablen auf Null setzt, muss das Optimierungsproblem in die <strong>Lagrange</strong>-Form (eingeschränkte Optimierung) gebracht werden:</p>
<p><span class="math display">\[
\text{Minimiere}\quad \frac{1}{2n} \sum_{i=1}^{n} \left(y_i - \hat{f}(\mathbf{x}_i) \right)^2 \text{unter der Bedingung}\quad \sum_{j=1}^p |w_j| \leq s
\]</span> <span class="math inline">\(s\)</span> kann als <strong>Budget</strong> interpretiert werden <span class="citation" data-cites="islr">(<a href="references.html#ref-islr" role="doc-biblioref">James u.&nbsp;a. 2021</a>, pp.&nbsp;241 - 245)</span> und die Summe über die absoluten Werte der Modellparameter kann dieses Budget nicht übersteigen.</p>
<p>Jedes Budget <span class="math inline">\(s\)</span> matcht einen Wert für <span class="math inline">\(\lambda\)</span>, so dass dieselben Modellparameter resultieren. Oder in anderen Worten: die Problemformulierung hier ist identisch zu der obigen mit dem Unterschied, dass sie hier durch <span class="math inline">\(s\)</span> charakterisiert ist und oben durch <span class="math inline">\(\lambda\)</span>.</p>
<p>Die Bedingung <span class="math inline">\(\sum_{j=1}^p |w_j| \leq s\)</span> kann im Fall von zwei Input-Variablen mit den entsprechenden Modellparameter <span class="math inline">\(w_1\)</span> und <span class="math inline">\(w_2\)</span> gut visualisert werden:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="02_linreg_files/figure-html/lasso-contours-1.png" class="img-fluid figure-img" style="width:60.0%" alt="Konturplot für LASSO."></p>
<figcaption>Konturplots der LASSO-Bedingung für drei verschiedene Budgets (1,2,3).</figcaption>
</figure>
</div>
</div>
</div>
<p>Die drei abgebildeten Rauten entsprechend den Budgets <span class="math inline">\(s=1,2,3\)</span>. Jede Raute enthalt alle Kombinationen von Parameterwerten, welche zusammen genau das Budget ergeben. Wenn wir uns beispielsweise den Eckpunkt ganz oben in der äussersten Raute anschauen, dann haben wir dort die Parameterwerte <span class="math inline">\(w_1=0\)</span> und <span class="math inline">\(w_2=3\)</span>; die Summe der absoluten Werte ist also genau 3.</p>
<p>Die optimalen LASSO Modellparameter befinden sich nun an dem Punkt, wo die Konturlinien für den ersten Teil der Kostenfunktion (die Summe der quadrierten Differenzen, siehe auch Konturlinien oben für Kleinstquadratemethode) die Konturlinie der LASSO-Bedingung für ein gegebenes Budget <span class="math inline">\(s\)</span> berühren. Ganz oft ist dieser Berührungspunkt in einer der Ecken. <strong>Wichtig</strong>: eine Ecke ist immer eine Parameterkombination, wo einer der Parameter den Wert 0 hat.</p>
</div>
</div>
</div>
<p>Der <strong>Nachteil</strong> von LASSO im Vergleich zu Ridge ist, dass es keine analytische Lösung gibt. In der praktischen Arbeit stört uns dies allerdings nur wenig, da <code>R</code> oder <code>Python</code> Packages gut gerüstet sind, um das Optimierungsproblem für LASSO zu lösen.</p>
<p><strong>Wichtig</strong>: wie bei Ridge müssen auch hier alle numerischen Input-Variablen zwingend standardisiert sein.</p>
</section>
</section>
<section id="bias-variance-tradeoff" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="bias-variance-tradeoff"><span class="header-section-number">2.6</span> Bias-Variance Tradeoff</h2>
<p>Wir haben oben bereits gesehen, dass der Hyperparameter <span class="math inline">\(\lambda\)</span> bestimmt, wie stark die Komplexität des Regressionsmodells eingeschränkt wird (oder in anderen Worten, die Parameter richtung Null geschrumpft werden).</p>
<p>Um noch besser zu verstehen, warum es so wichtig ist, die Komplexität eines Modells korrekt einzustellen, wollen wir uns nun mit einem ganz wichtigen Konzept im Machine Learning beschäftigen, nämlich dem <strong>Bias-Variance Tradeoff</strong>. Dieses Konzept kann <em>intuitiv</em> für alle Bereiche des Supervised Learnings angewendet werden. Für das Regressionsproblem können wir diesen Tradeoff jedoch auch <em>mathematisch</em> herleiten <span class="citation" data-cites="islr">(siehe auch <a href="references.html#ref-islr" role="doc-biblioref">James u.&nbsp;a. 2021</a>)</span> und genau das tun wir jetzt hier.</p>
<p>Stellen Sie sich vor, dass wir eine grosse Anzahl Trainingsdatensätze zur Verfügung haben und mit jedem dieser Datensätze versuchen wir den wahren funktionalen Zusammenhang <span class="math inline">\(f(\mathbf{x}_i)\)</span> möglichst gut mit <span class="math inline">\(\hat{f}(\mathbf{x}_i)\)</span> zu schätzen. Für jeden Datensatz sieht das geschätzte Modell <span class="math inline">\(\hat{f}(\mathbf{x}_i)\)</span> etwas anders aus (da es auf einem unterschiedlichen Datensatz trainiert wurde). Das geschätzte Modell, kurz <span class="math inline">\(\hat{f}\)</span>, variiert also je nach Datensatz und ist dementsprechend eine <strong>Zufallsvariable</strong>.</p>
<p>Ausserdem treffen wir folgende Annahmen:</p>
<ul>
<li>Von oben wissen wir, dass <span class="math inline">\(y_i = f(\mathbf{x}_i) + \epsilon\)</span> immer gilt.</li>
<li>Wir nehmen an, dass der Erwartungswert des nicht-lernbaren Teils <span class="math inline">\(\epsilon\)</span> Null ist, also <span class="math inline">\(\mathbb{E}[\epsilon]=0\)</span>.</li>
<li>Ausserdem gilt für die Varianz einer Zufallsvariable (in Kombination mit der zweiten Annahme, dass <span class="math inline">\(\mathbb{E}[\epsilon]=0\)</span>): <span class="math inline">\(\text{Var}(\epsilon) = \mathbb{E}[\epsilon^2] - \mathbb{E}[\epsilon]^2 = \mathbb{E}[\epsilon^2] - 0^2 = \mathbb{E}[\epsilon^2]\)</span>.</li>
</ul>
<p>Um den Bias-Variance Tradeoff zu zeigen, leiten wir nun den <strong>Erwartungswert des quadrierten Fehlers</strong> für eine gegebene Testbeobachtung her, die wir als <span class="math inline">\((y_0,\mathbf{x}_0)\)</span> bezeichnen. Dies wäre der durchschnittliche quadrierte Fehler, den wir für diese Beobachtung kriegen würden, wenn wir mit jedem geschätzten Modell die Vorhersage für diese Testbeobachtung rechnen würden.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-14-contents" aria-controls="callout-14" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Vorsicht</span>Herleitung (optional)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-14" class="callout-14-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>In einem ersten Schritt erweitern wir den quadrierten Fehler, indem wir einmal den wahren Funktionswert an der Stelle <span class="math inline">\(\mathbf{x}_0\)</span> abziehen und einmal hinzuzählen. Zusammen gibt das Null und verändert darum die rechte Seite der Gleichung nicht:</p>
<p><span class="math display">\[\begin{align}
\mathbb{E}\left[\left(y_0 - \hat{f}(\mathbf{x}_0)\right)^2\right] &amp;= \mathbb{E}\left[\left(y_0 - f(\mathbf{x}_0) + f(\mathbf{x}_0) - \hat{f}(\mathbf{x}_0)\right)^2\right]
\end{align}\]</span></p>
<p>Nun verwenden wir die bekannte polynomische Expansion <span class="math inline">\((a+b)^2=a^2+2ab+b^2\)</span>, aber hier behandeln wir <span class="math inline">\(y_0 - f(\mathbf{x}_0)\)</span> als <span class="math inline">\(a\)</span> und <span class="math inline">\(f(\mathbf{x}_0) - \hat{f}(\mathbf{x}_0)\)</span> als <span class="math inline">\(b\)</span>. Dadurch kriegen wir folgende Gleichung:</p>
<p><span class="math display">\[\begin{align}
\mathbb{E}\left[\left(y_0 - \hat{f}(\mathbf{x}_0)\right)^2\right] &amp;= \mathbb{E}\biggl[\left(y_0 - f(\mathbf{x}_0)\right)^2 \\
&amp;+ 2\left(y_0 - f(\mathbf{x}_0)\right)(f(\mathbf{x}_0) - \hat{f}(\mathbf{x}_0)) \\
&amp;+ (f(\mathbf{x}_0) - \hat{f}(\mathbf{x}_0))^2\biggr]
\end{align}\]</span></p>
<p>Nun wissen wir aus obigen Annahmen, dass der Erwartungswert von <span class="math inline">\(y_0\)</span> folgender ist: <span class="math inline">\(\mathbb{E}[y_0]=\mathbb{E}[f(\mathbf{x}_0) + \epsilon]=f(\mathbf{x}_0)\)</span>. Dadurch entfällt der erste Teil des zweiten Terms, weil <span class="math inline">\(\mathbb{E}[\left(y_0 - f(\mathbf{x}_0)\right)]=f(\mathbf{x}_0) - f(\mathbf{x}_0)=0\)</span>. Dadurch lässt sich das Ganze massiv vereinfachen zu:</p>
<p><span class="math display">\[\begin{align}
\mathbb{E}\left[\left(y_0 - \hat{f}(\mathbf{x}_0)\right)^2\right] &amp;= \mathbb{E}\left[\left(y_0 - f(\mathbf{x}_0)\right)^2\right] + \mathbb{E}\left[(f(\mathbf{x}_0) - \hat{f}(\mathbf{x}_0))^2\right]
\end{align}\]</span></p>
<p>Nun setzen wir im ersten Erwartungswert auf der rechten Seite anstelle von <span class="math inline">\(y_0\)</span> den Term <span class="math inline">\(f(\mathbf{x}_0) + \epsilon\)</span> ein und kriegen folgendes:</p>
<p><span class="math display">\[\begin{align}
\mathbb{E}\left[\left(y_0 - \hat{f}(\mathbf{x}_0)\right)^2\right] &amp;= \mathbb{E}\left[\left(f(\mathbf{x}_0) + \epsilon - f(\mathbf{x}_0)\right)^2\right] + \mathbb{E}\left[(f(\mathbf{x}_0) - \hat{f}(\mathbf{x}_0))^2\right] \\
&amp;= \mathbb{E}\left[\epsilon^2\right] + \mathbb{E}\left[(f(\mathbf{x}_0) - \hat{f}(\mathbf{x}_0))^2\right] \\
&amp;= \text{Var}(\epsilon) + \mathbb{E}\left[(f(\mathbf{x}_0) - \hat{f}(\mathbf{x}_0))^2\right]
\end{align}\]</span></p>
<p>Das ist schon mal ein erstes wichtiges Zwischenresultat. Der Erwartungswert des quadrierten Fehlers wird eine untere Grenze haben, die genau der Varianz des Fehlerterms, <span class="math inline">\(\text{Var}(\epsilon)\)</span>, entspricht. Diese untere Grenze des erwarteten Fehlers wird dann erreicht, wenn unser geschätztes Modell genau dem wahren entspricht und darum der zweite Term oben entfällt.</p>
<p>Nun wollen wir diesen zweiten Term oben noch etwas weiter aufspalten. Dazu brauchen wir wiederum den Trick, den wir oben bereits angewendet haben. Wir ziehen den Erwartungswert des geschätzten Modells <span class="math inline">\(\mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\)</span> einmal ab und fügen ihn einmal hinzu:</p>
<p><span class="math display">\[\begin{align}
\mathbb{E}\left[(f(\mathbf{x}_0) - \hat{f}(\mathbf{x}_0))^2\right] &amp;= \mathbb{E}\left[\left(f(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right] + \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right] - \hat{f}(\mathbf{x}_0)\right)^2\right] \\
&amp;= \mathbb{E}\left[\left(f(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right] - \left(\hat{f}(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\right)\right)^2\right]
\end{align}\]</span></p>
<p>Ähnlich wie weiter oben können wir diese Gleichung mit einer polynomischen Expansion wie folgt umschreiben:</p>
<p><span class="math display">\[\begin{align}
\mathbb{E}\left[(f(\mathbf{x}_0) - \hat{f}(\mathbf{x}_0))^2\right] &amp;= \mathbb{E}\biggl[\left(f(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\right)^2 \\
&amp;- 2\left(f(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\right)\left(\hat{f}(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\right) \\
&amp;+ \left(\hat{f}(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\right)^2\biggr]
\end{align}\]</span></p>
<p>Auch hier entfällt der mittlere Term, wenn wir den Erwartungswert in die Klammern reinnehmen, weil der zweite Teil <span class="math inline">\(\left(\mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right] - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\right)=0\)</span> ist.</p>
<p>Was übrig bleibt ist folgendes:</p>
<p><span class="math display">\[\begin{align}
\mathbb{E}\left[(f(\mathbf{x}_0) - \hat{f}(\mathbf{x}_0))^2\right] &amp;= \mathbb{E}\left[\left(f(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\right)^2\right] + \mathbb{E}\left[\left(\hat{f}(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\right)^2\right] \\
&amp;= \left(f(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\right)^2 + \mathbb{E}\left[\left(\hat{f}(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\right)^2\right]
\end{align}\]</span></p>
<p>Schauen wir uns kurz die beiden Komponenten auf der rechten Seite etwas genauer an:</p>
<ul>
<li><span class="math inline">\(\left(f(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\right)^2\)</span> ist der <strong>quadrierte Bias</strong> und misst die systematische Abweichung unseres geschätzten Modells <span class="math inline">\(\hat{f}\)</span> vom wahren unbekannten Modell <span class="math inline">\(f\)</span>. Je kleiner der Bias, desto tiefer der erwartete quadrierte Fehler. Wir können diesen Term der Einfachheit halber mit <span class="math inline">\(\left[\text{Bias}\left(\hat{f}(\mathbf{x}_0)\right)\right]^2\)</span> bezeichnen.</li>
<li><span class="math inline">\(\mathbb{E}\left[\left(\hat{f}(\mathbf{x}_0) - \mathbb{E}\left[\hat{f}(\mathbf{x}_0)\right]\right)^2\right]\)</span> ist nichts anderes als die Varianz unseres geschätzten Modells <span class="math inline">\(\hat{f}\)</span>. Sie misst, wie stark sich <span class="math inline">\(\hat{f}\)</span> im Schnitt verändert, wenn wir einen anderen Datensatz für das Training verwenden. Ein Modell mit hoher Varianz passt sich jeweils sehr stark an die Daten an. Je kleiner diese Varianz, desto tiefer der erwartete quadrierte Fehler. Wir bezeichnen diesen Term der Einfachheit halber als <span class="math inline">\(\text{Var}\left(\hat{f}(\mathbf{x}_0)\right)\)</span>.</li>
</ul>
<p>Nun sind wir endlich am Ziel angelangt und können den erwarteten quadrierten Fehler für die Beobachtung <span class="math inline">\((y_0,\mathbf{x}_0)\)</span> wie folgt aufschreiben:</p>
<p><span class="math display">\[
\mathbb{E}\left[\left(y_0 - \hat{f}(\mathbf{x}_0)\right)^2\right] = \text{Var}(\epsilon) + \left[\text{Bias}\left(\hat{f}(\mathbf{x}_0)\right)\right]^2 + \text{Var}\left(\hat{f}(\mathbf{x}_0)\right)
\]</span></p>
</div>
</div>
</div>
<p>Der erwartete quadrierte Fehler für die Beobachtung <span class="math inline">\((y_0,\mathbf{x}_0)\)</span> kann wie folgt beschrieben werden:</p>
<p><span class="math display">\[
\mathbb{E}\left[\left(y_0 - \hat{f}(\mathbf{x}_0)\right)^2\right] = \text{Var}(\epsilon) + \left[\text{Bias}\left(\hat{f}(\mathbf{x}_0)\right)\right]^2 + \text{Var}\left(\hat{f}(\mathbf{x}_0)\right)
\]</span></p>
<ul>
<li>Ein Modell mit <strong>viel Bias</strong>, also <span class="math inline">\(\text{Bias}\left(\hat{f}(\mathbf{x}_0)\right)\)</span>, führt zu einer schlechten Vorhersagequalität (auf Trainings- und Testdaten), weil das Modell zu rigide ist, um den wahren Zusammenhang zwischen der Output-Variable und den Input-Variablen zu modellieren. Beispiel: wir verwenden ein einfaches lineares Regressionsmodell, um einen stark nicht-linearen Zusammenhang zwischen <span class="math inline">\(y_i\)</span> und <span class="math inline">\(\mathbf{x}_i\)</span> zu modellieren. Im Fall von Modellen mit viel Bias spricht man auch von <strong>Underfitting</strong>.</li>
<li>Ein Modell mit <strong>viel Varianz</strong> führt zu einer hervorragenden Vorhersagequalität auf den Trainingsdaten, aber zu einer sehr schlechten Vorhersagequalität auf den Testdaten. Das Problem hier ist, dass das Model zu flexibel ist gemessen an der Grösse des Trainingsdatensatzes. Das Modell passt sich so zu stark an die Trainingsdaten an und modelliert auch sogenanntes <strong>Noise</strong>, also <span class="math inline">\(\epsilon\)</span> (und nicht nur das <strong>Signal</strong> in den Daten). Beispiel: wir modellieren ein neuronales Netzwerk, haben aber nur einen Trainingsdatensatz von einigen hundert Beobachtungen. Im Fall von Modellen mit viel Varianz spricht man auch von <strong>Overfitting</strong>.</li>
<li>Der dritte Term, <span class="math inline">\(\text{Var}(\epsilon)\)</span>, ist die Varianz des Fehlerterms. Es ist der nicht-reduzierbare Teil des erwartbaren Vorhersagefehlers, d.h., wir erwarten selbst wenn wir das bestmögliche Modell gefunden haben einen gewissen Fehler.</li>
</ul>
<p>Warum spricht man von einem <strong>Tradeoff</strong>? Flexiblere Modelle haben oft einen kleinen Bias, aber hohe Varianz, während unflexible Modelle oft eine kleine Varianz, aber einen hohen Bias haben. Es existiert also ein Tradeoff zwischen Bias und Varianz und wir wollen beim Modellieren und vor allem beim Hyperparameter Tuning (zum Beispiel <span class="math inline">\(\lambda\)</span>) den optimalen Tradeoff finden.</p>
<section id="regularisierte-regression-revisited" class="level4">
<h4 class="anchored" data-anchor-id="regularisierte-regression-revisited">Regularisierte Regression revisited</h4>
<p>Der Hyperparameter <span class="math inline">\(\lambda\)</span> spielt bei der regularisierten Regression eine zentrale Rolle für den Tradeoff zwischen Bias und Variance. Ein zu tiefer Wert für <span class="math inline">\(\lambda\)</span> kann zu einem zu flexiblen Modell mit viel Varianz führen. Ein zu hoher Wert für <span class="math inline">\(\lambda\)</span> führt zu einem zu rigiden Modell mit viel Bias.</p>
<p>Im folgenden Beispiel haben wir <span class="math inline">\(n = 50\)</span> Beobachtungen. Die Daten wurden durch folgenden Prozess generiert:</p>
<p><span class="math display">\[
y_i = 2 + 1 \cdot x_{i,1} + \epsilon_i
\]</span> wobei <span class="math inline">\(\epsilon_i \sim N(0, 0.2)\)</span>. Das wahre Modell ist dementsprechend <span class="math inline">\(f(\mathbf{x}_i) = 2 + 1 \cdot x_{i,1}\)</span>.</p>
<p>Der Datensatz enthält aber 49 weitere Prädiktoren <span class="math inline">\(x_{i,2}, x_{i,3}, \dots, x_{i,50}\)</span>, welche nicht mit der Output-Variable <span class="math inline">\(y_i\)</span> korreliert sind. Als Analyst:in wissen Sie das jedoch nicht. Sie sehen lediglich die 50 Input-Variablen und die Output-Variable.</p>
<p>Folgende Abbildung zeigt die Resultate von vier LASSO Modellen mit unterschiedlichen Werten für <span class="math inline">\(\lambda\)</span>.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="02_linreg_files/figure-html/lasso-params-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Einfluss von Hyperparameter auf Modellparameter."></p>
<figcaption>Resultate eines LASSO Modells für vier verschiedene Werte des Hyperparameters. Links: die trainierten Parameterwerte für die Konstante sowie die 50 Input-Variablen. Rechts: Vorhersagegüte (gemessen als RMSE) auf Trainings- und Testdaten. Für die Testdaten wurden weitere 50 Beobachtungen generiert, die aber nicht für das Training verwendet wurden.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="frage-2" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="frage-2">Frage</h4>
<p>Welches der vier abgebildeten Modelle mit entsprechendem Wert für <span class="math inline">\(\lambda\)</span> ist optimal?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-15-contents" aria-controls="callout-15" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tipp</span>Lösung
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-15" class="callout-15-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Das dritte Modell mit <span class="math inline">\(\lambda = 0.1\)</span> ist optimal. Wir sehen, dass in diesem Fall nur die Gewichte <span class="math inline">\(w_0 \approx 2\)</span> und <span class="math inline">\(w_1 \approx 1\)</span> nicht Null sind. Ausserdem sind die beiden RMSE Werte auf Trainings- und Testdaten ähnlich und auf tiefem Niveau.</p>
<p>Das erste Modell (<span class="math inline">\(\lambda = 0\)</span>) entspricht der Kleinstquadratemethode und ist ein gutes Beispiel für Overfitting. Das Modell verwendet alle 50 Input-Variablen und kann so den RMSE auf den Trainingsdaten fast auf 0 reduzieren. Der Testdaten-RMSE ist dann aber vergleichsweise hoch - ein typisches Zeichen von Overfitting.</p>
<p>Der vierte Modell (<span class="math inline">\(\lambda = 10\)</span>) ist ein perfektes Beispiel von Underfitting. Der Regularisierungsterm <span class="math inline">\(\lambda\)</span> ist so gross, dass nur noch ein Modell mit einer Konstante <span class="math inline">\(w_0 \approx 2\)</span> geschätzt wurde. Entsprechend sind sowohl der RMSE auf den Trainingsdaten als auch der RMSE auf den Testdaten hoch - ein typisches Zeichen von Underfitting.</p>
<p>Das zweite Modell ist nicht schlecht, aber zeigt immer noch leichte Anzeichen von Overfitting.</p>
</div>
</div>
</div>
<p><strong>Wichtig:</strong></p>
<ul>
<li>Indem wir den Hyperparameter via Resampling (z.B. K-Fold Cross Validation, später mehr dazu) optimieren, wählen wir automatisch ein Modell mit einem guten Tradeoff zwischen Bias und Varianz!</li>
<li>Mit grossen Datensätzen ist das Problem des Overfittings weniger dramatisch. Haben wir genügend Trainingsdaten, dann können selbst flexible Modelle nicht zu stark overfitten. Die Anzahl Trainingsdaten hat also einen regulierenden Einfluss.</li>
</ul>
<p>Eine letzte Überlegung bezüglich Modellselektion geht folgendermassen: wenn wir mehrere Modelle haben, die ähnlich gut performen, dann wählen wir das einfachste (kleinste) oder <strong>am wenigsten komplexe Modell</strong>. Man nennt dies <strong>Occam’s Razor</strong>. William of Occam war ein Englischer Mönch und hat dieses Prinzip in einem anderen Kontext erstmals formuliert.</p>
</section>
</section>
<section id="polynomische-regression" class="level2" data-number="2.7">
<h2 data-number="2.7" class="anchored" data-anchor-id="polynomische-regression"><span class="header-section-number">2.7</span> Polynomische Regression</h2>
<p>Wir machen hier nun einen kurzen Abstecher und lernen die <strong>polynomische Regression</strong> kennen, denn diese eignet sich auch sehr gut, um den Bias-Variance Tradeoff zu illustrieren.</p>
<p>Das polynomische Regressionsmodell sieht im Fall von <em>einer</em> Input-Variable <span class="math inline">\(x_i\)</span> folgendermassen aus:</p>
<p><span class="math display">\[
y_i = w_0 + w_1 \cdot x_i^1 + w_2 \cdot x_i^2 + w_3 \cdot x_i^3 + \dotsb + w_M \cdot x_i^M + \epsilon_i
\]</span></p>
<p>Es handelt sich also um ein Regressionsmodell wie wir es kennen gelernt haben, einfach mit den Polynomen von <span class="math inline">\(x_i\)</span> bis zum <span class="math inline">\(M\)</span>-ten Grad als Input-Variablen.</p>
<p>Mit einem Datensatz der Grösse <span class="math inline">\(n\)</span>, kann ein polynomisches Regressionsmodell mit Grad <span class="math inline">\(M = n−1\)</span> die Daten perfekt abbilden. Das Modell hat in diesem Fall so viele Freiheitsgrade wie der Trainingsdatensatz Beobachtungen hat. Dabei handelt es sich um ein <strong>extremes Beispiel von Overfitting</strong>.</p>
<p>Wir sehen in untenstehender Abbildung drei Fälle einer polynomischen Regression. Die schwarze Kurve zeigt das wahre Modell, von dem die blauen Datenpunkte unter Hinzufügen von etwas Noise generiert wurden. Die braune Kurve zeigt das jeweils geschätzte Modell. Rechts sehen Sie ähnlich wie oben jeweils den RMSE auf Trainings- und auf Testdaten.</p>
<p>Folgende Punkte gilt es festzuhalten:</p>
<ul>
<li>Das erste Modell ist eine polynomische Regression mit Grad <span class="math inline">\(M=0\)</span>, in der nur die Konstante <span class="math inline">\(w_0\)</span> in das Modell einfliesst. Ein klarer Fall von <strong>Underfitting</strong>.</li>
<li>Das zweite Modell ist eine polynomische Regression mit Grad <span class="math inline">\(M=9\)</span>, das mit <span class="math inline">\(n=10\)</span> Beobachtungen trainiert wird - das bereits angesprochene Beispiel von extremem <strong>Overfitting</strong>.</li>
<li>Beim dritten Modell zeigt sich der regulierende Effekt von mehr Trainingsdaten. Das komplexe Modell mit <span class="math inline">\(M=9\)</span> führt im Fall von <span class="math inline">\(n=100\)</span> Trainingsbeobachtungen zu einem sehr guten Fit.</li>
</ul>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="02_linreg_files/figure-html/poly-reg-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Polynomische Regression."></p>
<figcaption>Polynomische Regression für drei verschiedene Fälle mit unterschiedlichen polynomischen Graden und Anzahl Trainingsbeobachtungen. Rechts: Vorhersagegüte (gemessen als RMSE) auf Trainings- und Testdaten. Für die Testdaten wurden weitere n Beobachtungen generiert, die aber nicht für das Training verwendet wurden.</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Wichtig</strong>: das polynomische Regressionsmodell ist immer noch <strong>linear in den Parametern</strong>, es handelt sich also immer noch um ein lineares Modell. Sie sehen aber an obigen Modellkurven, dass dieses “lineare” Modell sehr wohl in der Lage ist, nicht-lineare Zusammenhänge zwischen <span class="math inline">\(x\)</span> und <span class="math inline">\(y\)</span> zu fitten!</p>
</section>
<section id="lineare-regression-in-r" class="level2" data-number="2.8">
<h2 data-number="2.8" class="anchored" data-anchor-id="lineare-regression-in-r"><span class="header-section-number">2.8</span> Lineare Regression in R</h2>
<section id="base-r" class="level3" data-number="2.8.1">
<h3 data-number="2.8.1" class="anchored" data-anchor-id="base-r"><span class="header-section-number">2.8.1</span> Base <code>R</code></h3>
<p>In Base <code>R</code> lassen sich Regressionsmodelle einfach mit der <code>lm()</code> Funktion (<code>lm</code> steht für <em>linear model</em>) rechnen.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Datenpunkte</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">4.1</span>, <span class="sc">-</span><span class="fl">0.5</span>, <span class="fl">1.4</span>, <span class="fl">4.4</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">3.5</span>, <span class="fl">1.95</span>, <span class="sc">-</span><span class="fl">2.5</span>, <span class="sc">-</span><span class="fl">2.05</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Dataframe</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">x =</span> x, <span class="at">y =</span> y)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Modellrechnung (Kleinsquadrateschätzer)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>mod <span class="ot">&lt;-</span> <span class="fu">lm</span>(y <span class="sc">~</span> x, <span class="at">data =</span> df)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Modelloutput</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mod)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = y ~ x, data = df)

Residuals:
       1        2        3        4 
 0.02129  1.13342 -1.91157  0.75686 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)
(Intercept)   0.4468     0.8340   0.536    0.646
x            -0.7395     0.2692  -2.747    0.111

Residual standard error: 1.66 on 2 degrees of freedom
Multiple R-squared:  0.7904,    Adjusted R-squared:  0.6857 
F-statistic: 7.544 on 1 and 2 DF,  p-value: 0.1109</code></pre>
</div>
</div>
<p>Der obige <code>R</code> Output ist der klassische Regressionsoutput der <code>lm()</code> Funktion. In der Spalte <code>Estimate</code> sehen wir insbesondere die geschätzten (trainierten) Modellparameter.</p>
<p>Wir können unser geschätztes Modell nun wie folgt verwenden, um Vorhersagen für zwei neue Input-Variablenwerte (2.5 und 5.1) zu machen.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Modellvorhersagen</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>yp <span class="ot">&lt;-</span> <span class="fu">predict</span>(mod, <span class="at">newdata =</span> <span class="fu">data.frame</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="fl">2.5</span>, <span class="fl">5.1</span>)))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>yp</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>        1         2 
-1.401854 -3.324500 </code></pre>
</div>
</div>
</section>
<section id="tidymodels-glmnet" class="level3" data-number="2.8.2">
<h3 data-number="2.8.2" class="anchored" data-anchor-id="tidymodels-glmnet"><span class="header-section-number">2.8.2</span> <code>tidymodels</code> + <code>glmnet</code></h3>
<p>Für regularisierte Regressionsmodelle eignet sich der <code>tidymodels</code> <a href="https://www.tidymodels.org/">Framework</a> in Kombination mit <code>glmnet</code> (letzteres ist die Engine für regularisierte Modelle aller Art). Wir laden als erstes die beiden Packages. Beim ersten Mal müssen diese Packages mit <code>install.packages(c("tidymodels", "glmnet"))</code> installiert werden.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidymodels)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(glmnet)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Wir generieren hier dieselben Daten wie in einer der Demos oben, wo wir die regularisierte Regression demonstriert haben. Die Daten werden wie oben nach folgendem Modell generiert:</p>
<p><span class="math display">\[
y_i = 2 + 1 \cdot x_{i,1} + \epsilon_i
\]</span> Der folgende Code-Block generiert die Daten:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Seed für Reproduzierbarkeit</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Wir definieren die Anzahl Beobachtungen, die Anzahl Input-Var.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># und die Standardabweichung des Fehlerterms.</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">50</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="dv">50</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>sd <span class="ot">&lt;-</span> <span class="fl">0.2</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Nun simulieren wir die Input-Variablenwerte aus einer Normalverteilung.</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>Xtrain <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(n <span class="sc">*</span> p), <span class="at">nrow =</span> n)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Generierung der y-Werte mit normalverteiltem Noise.</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>ytrain <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">+</span> Xtrain[, <span class="dv">1</span>] <span class="sc">+</span> <span class="fu">rnorm</span>(n, <span class="dv">0</span>, sd)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Wir fassen die Input-Variablen und den Output zu einem Dataframe zusammen.</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>train <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(Xtrain)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>train<span class="sc">$</span>y <span class="ot">&lt;-</span> ytrain</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Im folgenden Code verwenden wir <code>tidymodels</code>, um ein lineares Regressionsmodell mit <code>linear_reg()</code> zu initialisieren. In <code>tidymodels</code> heisst der Hyperparameter <span class="math inline">\(\lambda\)</span> <code>penalty</code> und mit <code>mixture = 1</code> definieren wir, dass ein LASSO Modell gerechnet werden soll (<code>mixture = 0</code> würde einem Ridge Modell entsprechen).</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Modellspezifikation für lineares Modell mit Regularisierung</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>lm_mod <span class="ot">&lt;-</span> </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">linear_reg</span>(<span class="at">penalty =</span> <span class="fl">0.1</span>, <span class="at">mixture =</span> <span class="dv">1</span>) <span class="sc">|&gt;</span> </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_engine</span>(<span class="st">"glmnet"</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Nun fitten wir das Modell mit <code>fit()</code>. Mit <code>formula = y ~ .</code> legen wir fest, dass <code>y</code> die Outputvariable ist und dass alle anderen Variablen im Dataframe <code>train</code> als Input-Variablen verwendet werden sollen.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Modelltraining</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>lm_fit <span class="ot">&lt;-</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  lm_mod <span class="sc">|&gt;</span> </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fit</span>(<span class="at">formula =</span> y <span class="sc">~</span> ., <span class="at">data =</span> train)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Nun können wir uns noch die trainierten Modellparameter (in der Spalte <code>estimate</code>) anschauen.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameter des Modells</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tidy</span>(lm_fit) <span class="sc">%&gt;%</span> </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="at">n =</span> <span class="dv">51</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 51 × 3
   term        estimate penalty
   &lt;chr&gt;          &lt;dbl&gt;   &lt;dbl&gt;
 1 (Intercept)    2.00      0.1
 2 V1             0.887     0.1
 3 V2             0         0.1
 4 V3             0         0.1
 5 V4             0         0.1
 6 V5             0         0.1
 7 V6             0         0.1
 8 V7             0         0.1
 9 V8             0         0.1
10 V9             0         0.1
11 V10            0         0.1
12 V11            0         0.1
13 V12            0         0.1
14 V13            0         0.1
15 V14            0         0.1
16 V15            0         0.1
17 V16            0         0.1
18 V17            0         0.1
19 V18            0         0.1
20 V19            0         0.1
21 V20            0         0.1
22 V21            0         0.1
23 V22            0         0.1
24 V23            0         0.1
25 V24            0         0.1
26 V25            0         0.1
27 V26            0         0.1
28 V27            0         0.1
29 V28            0         0.1
30 V29            0         0.1
31 V30            0         0.1
32 V31            0         0.1
33 V32            0         0.1
34 V33            0         0.1
35 V34            0         0.1
36 V35            0         0.1
37 V36            0         0.1
38 V37            0         0.1
39 V38            0         0.1
40 V39            0         0.1
41 V40            0         0.1
42 V41            0         0.1
43 V42            0         0.1
44 V43            0         0.1
45 V44            0         0.1
46 V45            0         0.1
47 V46            0         0.1
48 V47            0         0.1
49 V48            0         0.1
50 V49            0         0.1
51 V50            0         0.1</code></pre>
</div>
</div>
<p><strong>Vorschlag</strong>: Kopieren Sie die Codezeilen in ein lokales Skript und probieren Sie andere Werte für den Hyperparameter <span class="math inline">\(\lambda\)</span> (<code>penalty</code>) aus.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-islr" class="csl-entry" role="listitem">
James, Gareth, Daniela Witten, Trevor Hastie, und Robert Tibshirani. 2021. <em>An Introduction to Statistical Learning: with Applications in R</em>. 2. Aufl. Springer. <a href="https://www.statlearning.com/">https://www.statlearning.com/</a>.
</div>
</div>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p><span class="math inline">\(\epsilon = y_i - f(\mathbf{x}_i)\)</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>So müssen wir die Konstante <span class="math inline">\(w_0\)</span> nicht separat aufschreiben.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Das Quadrieren führt dazu, dass grosse Differenzen die gesamte Summe der quadrierten Fehler dominieren.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Falls Sie den optionalen Teil “Kleinsquadratemethode in Matrixform” angeschaut haben: in diesem Fall ist die Matrix <span class="math inline">\(\mathbf{X}'\mathbf{X}\)</span> nicht invertierbar.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Formel für die Standardisierung: <span class="math inline">\(\frac{y_i-\bar{y}}{s_y}\)</span><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>LASSO ist die Abkürzung für <em>least absolute shrinkage and selection operator</em><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Kopiert");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Kopiert");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./classical.html" class="pagination-link" aria-label="Klassisches Machine Learning">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Klassisches Machine Learning</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./03_linclass.html" class="pagination-link" aria-label="Lineare Klassifikation">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Lineare Klassifikation</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2026, Martin Sterchi</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="https://www.martinsterchi.ch">
<p>https://www.martinsterchi.ch</p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>